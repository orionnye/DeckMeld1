{"mappings":"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","sources":["node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-77175d52377a060e.js","node_modules/@parcel/runtime-js/lib/runtime-9f01173bce7e4493.js","node_modules/@parcel/runtime-js/lib/runtime-2b6bd838366c4d32.js","node_modules/@parcel/runtime-js/lib/runtime-315f033c7fa0a7f1.js","node_modules/@parcel/runtime-js/lib/runtime-832887e8ffb0cb65.js","node_modules/@parcel/runtime-js/lib/runtime-cecf0936936d8c70.js","node_modules/@parcel/runtime-js/lib/runtime-e7252b9867f9e74a.js","node_modules/@parcel/runtime-js/lib/runtime-b9973b58e0c1fe84.js","node_modules/@parcel/runtime-js/lib/runtime-7a6d8b33ddae6c63.js","node_modules/@parcel/runtime-js/lib/runtime-8db1aa2490084ebd.js","node_modules/@parcel/runtime-js/lib/runtime-74048c43f862447f.js","node_modules/@parcel/runtime-js/lib/runtime-d6e3e144b494b97e.js","node_modules/@parcel/runtime-js/lib/runtime-7a66543884253e79.js","node_modules/@parcel/runtime-js/lib/runtime-e621774e7adf0a3f.js","node_modules/@parcel/runtime-js/lib/runtime-3dbfb83c9150a404.js","node_modules/@parcel/runtime-js/lib/runtime-a8d964e17dc6a488.js","node_modules/@parcel/runtime-js/lib/runtime-26c986fa76658c3e.js","node_modules/@parcel/runtime-js/lib/runtime-4e31fecd0288474e.js","node_modules/@parcel/runtime-js/lib/runtime-6c105b5da5e63206.js","node_modules/@parcel/runtime-js/lib/runtime-c9d51fc4c8165510.js","node_modules/@parcel/runtime-js/lib/runtime-58238e1e342ce21e.js","node_modules/@parcel/runtime-js/lib/runtime-e63b08afc113453f.js","node_modules/@parcel/runtime-js/lib/runtime-1c89f6bbfc29086b.js","node_modules/@parcel/runtime-js/lib/runtime-8ea7256ffbdc4f55.js","node_modules/@parcel/runtime-js/lib/runtime-bc7f43ea4c6ee5ec.js","node_modules/@parcel/runtime-js/lib/runtime-000e1bb16c60d9c3.js","node_modules/@parcel/runtime-js/lib/runtime-38e00d1bf204c78c.js","node_modules/@parcel/runtime-js/lib/runtime-7a79b94d9292aa3f.js","node_modules/@parcel/runtime-js/lib/runtime-dd9e02654e8264b2.js","node_modules/@parcel/runtime-js/lib/runtime-33303cc9aa79f5d6.js","node_modules/@parcel/runtime-js/lib/runtime-e50131b27de0df41.js","node_modules/@parcel/runtime-js/lib/runtime-7b1d04a8016d5907.js","node_modules/@parcel/runtime-js/lib/runtime-adf538c956bfd66e.js","node_modules/@parcel/runtime-js/lib/runtime-63b381c7234e41e0.js","node_modules/@parcel/runtime-js/lib/runtime-ef97e3914d86e1b4.js","node_modules/@parcel/runtime-js/lib/runtime-199db30446849778.js","node_modules/@parcel/runtime-js/lib/runtime-d0dc259b3f32c803.js","node_modules/@parcel/runtime-js/lib/runtime-5d3d0e2f286d546f.js","node_modules/@parcel/runtime-js/lib/runtime-1809ddd15a5abaa9.js","node_modules/@parcel/runtime-js/lib/runtime-e95e7b349e481c19.js","node_modules/@parcel/runtime-js/lib/runtime-e0d12b73bdae91cf.js","node_modules/@parcel/runtime-js/lib/runtime-135e23487348baa3.js","node_modules/@parcel/runtime-js/lib/runtime-d0035871e29efb0e.js","node_modules/@parcel/runtime-js/lib/runtime-476ce70fa1f5d781.js","node_modules/@parcel/runtime-js/lib/runtime-dac1c371fb3d9f9c.js","node_modules/@parcel/runtime-js/lib/runtime-04c37ad2c4a8973b.js","node_modules/@parcel/runtime-js/lib/runtime-3fec62500a8af972.js","node_modules/@parcel/runtime-js/lib/runtime-b73ef1bcbef0f42e.js","node_modules/@parcel/runtime-js/lib/runtime-9f05fee472aecc51.js","node_modules/@parcel/runtime-js/lib/runtime-0957bf334a91ff09.js","node_modules/@parcel/runtime-js/lib/runtime-08137c9ca2e764cb.js","node_modules/@parcel/runtime-js/lib/runtime-15f882de4b677655.js","node_modules/@parcel/runtime-js/lib/runtime-ab40edced7ba8dfe.js","node_modules/@parcel/runtime-js/lib/runtime-fa8856401d948e7d.js","node_modules/@parcel/runtime-js/lib/runtime-2f527c48d6248f74.js","node_modules/@parcel/runtime-js/lib/runtime-d7687c7c1faddd01.js","node_modules/@parcel/runtime-js/lib/runtime-4441dcd2fa012690.js","node_modules/@parcel/runtime-js/lib/runtime-546a69d99700b5a5.js","node_modules/@parcel/runtime-js/lib/runtime-520e919cab9adc74.js","src/math/math.ts","src/math/Vector.ts","src/math/Matrix.ts","src/common/utils.ts","src/common/Graphics.ts","src/gameobjects/map/Tile.ts","src/gameobjects/map/Tiles.ts","node_modules/simplex-noise/simplex-noise.ts","src/gameobjects/map/Grid.ts","src/gameobjects/map/pathfinding.ts","src/common/Scene.ts","src/gameobjects/mech/Team.ts","src/gameobjects/card/CardTypes.ts","src/gameobjects/card/Card.ts","src/gameobjects/ui/CardTray.ts","src/gameobjects/ui/UnitTray.ts","src/gameobjects/mech/AI.ts","src/gameobjects/Camera.ts","src/stages/Match.ts","src/common/Input.ts","src/common/Clock.ts","src/common/names.ts","src/gameobjects/card/Deck.ts","src/gameobjects/mech/Unit.ts","src/gameobjects/mech/RigTypes.ts","src/stages/CardStore.ts","src/stages/Title.ts","src/stages/Origin.ts","src/stages/Lose.ts","src/stages/DealerShip.ts","src/stages/pawnShop.ts","src/stages/route/LinkedList.ts","src/stages/route/Route.ts","node_modules/@parcel/runtime-js/lib/runtime-96389903a8c8ef11.js","src/Game.ts","node_modules/@parcel/runtime-js/lib/runtime-c01c172fbe3efa7d.js","src/index.ts"],"sourcesContent":["\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"1Ntva\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"lvMDJ\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"i5xkB\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"gH1Or\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"lVG3x\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"jtKuZ\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"kL1YC\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"52U4m\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"dOBRO\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"gT0Zu\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"cUtHr\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"2GBAK\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"5AP31\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"dVcqF\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"8SU7g\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"8iSqe\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"cLwn2\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"3wsni\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"84CUC\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"jMTFx\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"a9P2a\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"7TrJz\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"2iNK1\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"fFSfK\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"gV6tH\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"98LW9\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"7dFi9\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"fHPrZ\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"bgHtf\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"a366i\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"22lZr\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"1s5R0\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"6Pi2O\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"3xD1x\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"cjRqQ\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"bwifq\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"iuNEp\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"iOTLM\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"ac7FO\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"lOtdr\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"iPZUs\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"ilUqy\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"4G08l\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"3l74Z\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"iGhmO\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"8ho0c\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"7ZN5Q\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"6NsjC\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"fkvli\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"2Ayx5\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"2V8nT\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"h38Gm\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"l34qm\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"bpkt7\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"aAEpa\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"2RzGY\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"7BlcN\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"bO2Wm\")).toString();","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"dZpbI\\\":\\\"index.ad6db622.js\\\",\\\"1Ntva\\\":\\\"grassFlipped.5db800e2.png\\\",\\\"lvMDJ\\\":\\\"hill5.71ce96e7.png\\\",\\\"i5xkB\\\":\\\"ShallowWater.0acbc1d7.png\\\",\\\"gH1Or\\\":\\\"DeepWater.51a9c4d4.png\\\",\\\"lVG3x\\\":\\\"ancientmech.d2b58418.png\\\",\\\"jtKuZ\\\":\\\"pustule.2c97757f.png\\\",\\\"kL1YC\\\":\\\"card.ffefd8a2.png\\\",\\\"52U4m\\\":\\\"laser.e2917381.png\\\",\\\"dOBRO\\\":\\\"EnergyArmor.91bbd9a2.png\\\",\\\"gT0Zu\\\":\\\"ShieldCharge.93b851ee.png\\\",\\\"cUtHr\\\":\\\"energyFist.dd669ee0.png\\\",\\\"2GBAK\\\":\\\"barrier.ae85dd2c.png\\\",\\\"5AP31\\\":\\\"boulder.0f1b3003.png\\\",\\\"dVcqF\\\":\\\"mine.9c0fde6d.png\\\",\\\"8SU7g\\\":\\\"gorge.f76efd83.png\\\",\\\"8iSqe\\\":\\\"blastCharge.c12540c9.png\\\",\\\"cLwn2\\\":\\\"dynamite.8c68b21f.png\\\",\\\"3wsni\\\":\\\"plating.c0f37ca4.png\\\",\\\"84CUC\\\":\\\"claw.9b122a62.png\\\",\\\"jMTFx\\\":\\\"frendzi.5208d098.png\\\",\\\"a9P2a\\\":\\\"leap.f074414d.png\\\",\\\"7TrJz\\\":\\\"lump.75a0340c.png\\\",\\\"2iNK1\\\":\\\"chomp.8b5efbc8.png\\\",\\\"fFSfK\\\":\\\"acid.9c24e68b.png\\\",\\\"gV6tH\\\":\\\"bloodClot.7ebcff0c.png\\\",\\\"98LW9\\\":\\\"sprint.0ec05625.png\\\",\\\"7dFi9\\\":\\\"repair.f2631c26.png\\\",\\\"fHPrZ\\\":\\\"grapplingHook.694cda09.png\\\",\\\"bgHtf\\\":\\\"Gun.ff3b07e1.png\\\",\\\"a366i\\\":\\\"pollen.ace413e3.png\\\",\\\"22lZr\\\":\\\"fruit.14086b5f.png\\\",\\\"1s5R0\\\":\\\"root.f730cd59.png\\\",\\\"6Pi2O\\\":\\\"flower.02b2d95d.png\\\",\\\"3xD1x\\\":\\\"bark.98f9cbef.png\\\",\\\"cjRqQ\\\":\\\"fungus.675dc5de.png\\\",\\\"bwifq\\\":\\\"boomShroom.2553e318.png\\\",\\\"iuNEp\\\":\\\"worms.a725db08.png\\\",\\\"iOTLM\\\":\\\"jelly.ad1c7988.png\\\",\\\"ac7FO\\\":\\\"tentacle.5303b84a.png\\\",\\\"lOtdr\\\":\\\"warp.c2153036.png\\\",\\\"iPZUs\\\":\\\"frost.0f1da465.png\\\",\\\"ilUqy\\\":\\\"flesh.ee34fa2e.png\\\",\\\"4G08l\\\":\\\"BlackCardBase.7fe05243.png\\\",\\\"3l74Z\\\":\\\"BrownCardBase.709c729a.png\\\",\\\"iGhmO\\\":\\\"jungle.0579f7d9.png\\\",\\\"8ho0c\\\":\\\"metal.0bbc6e92.png\\\",\\\"7ZN5Q\\\":\\\"purple.9bb8f249.png\\\",\\\"6NsjC\\\":\\\"grass.2dd11e56.png\\\",\\\"fkvli\\\":\\\"ChromeMech2.9ff9692c.png\\\",\\\"2Ayx5\\\":\\\"Vinecent2.81f341a5.png\\\",\\\"2V8nT\\\":\\\"EarthMech.f0d58cbe.png\\\",\\\"h38Gm\\\":\\\"flesh3.47652314.png\\\",\\\"l34qm\\\":\\\"GellyMech.1cc0ecc3.png\\\",\\\"bpkt7\\\":\\\"BackgroundPixel1.abf6fd00.png\\\",\\\"aAEpa\\\":\\\"BackgroundPixel2.65a37ceb.png\\\",\\\"2RzGY\\\":\\\"BackgroundPixel3.0f6d9f6f.png\\\",\\\"7BlcN\\\":\\\"BackgroundPixel4.9a699cfd.png\\\",\\\"bO2Wm\\\":\\\"grunt.10e90e0d.png\\\",\\\"cgtuV\\\":\\\"Vacation.3e7a8d6e.mp3\\\",\\\"eLZc0\\\":\\\"Knock.46cab22d.mp3\\\"}\"));","import { Vector } from \"./Vector\"\n\nconst epsilon = 0.00001\n\nexport function equals( a: number, b: number ) {\n    return Math.abs( a - b ) < epsilon\n}\n\nexport function randomFloor( upperLimit: number ) {\n    return Math.floor( Math.random() * upperLimit )\n}\nexport function randomCeil( upperLimit: number ) {\n    return Math.ceil( Math.random() * upperLimit )\n}\nexport function randomInt( upperLimit: number ) {\n    return Math.random() * upperLimit\n}\n\nexport class AABB {\n    minx: number\n    miny: number\n    maxx: number\n    maxy: number\n\n    constructor( minx: number, miny: number, maxx: number, maxy: number ) {\n        this.minx = minx\n        this.miny = miny\n        this.maxx = maxx\n        this.maxy = maxy\n    }\n\n    static fromDimensions( pos: Vector, dimensions: Vector ) {\n        return new AABB( pos.x, pos.y, pos.x + dimensions.x, pos.y + dimensions.y )\n    }\n\n    hull( a: AABB, b: AABB ) {\n        function min( x, y ) { return Math.min( x, y ) }\n        function max( x, y ) { return Math.max( x, y ) }\n        return new AABB(\n            min( a.minx, b.minx ),\n            min( a.miny, b.miny ),\n            max( a.maxx, b.maxx ),\n            max( a.maxy, b.maxy ),\n        )\n    }\n\n    contains( p: Vector ) {\n        let { minx, miny, maxx, maxy } = this\n        return p.x >= minx && p.x <= maxx && p.y >= miny && p.y <= maxy\n    }\n}\n\nexport function contains( min: number, max: number, x: number ) {\n    return x >= min && x <= max\n}\n\nexport function contains2D( pos: Vector, width: number, height: number, pt: Vector ) {\n    return contains( pos.x, pos.x + width, pt.x ) && contains( pos.y, pos.y + height, pt.y )\n}\n\nexport function clamp( min: number, max: number, x: number ) {\n    return ( x < min ) ? min : ( ( x > max ) ? max : x )\n}\n\nexport function lerp( start: number, end: number, alpha: number ) {\n    return ( end - start ) * alpha + start\n}","import { clamp, equals } from \"./math\"\n\nexport class Vector {\n    x: number\n    y: number\n    static zero = new Vector( 0, 0 )\n    static one = new Vector( 1, 1 )\n    static right = new Vector( 1, 0 )\n    static down = new Vector( 0, 1 )\n    constructor( x, y ) {\n        this.x = x\n        this.y = y\n    }\n    subtract( other: Vector ) { return new Vector( this.x - other.x, this.y - other.y ) }\n    add( other: Vector ) { return new Vector( this.x + other.x, this.y + other.y ) }\n    addXY( x: number, y: number ) { return new Vector( this.x + x, this.y + y ) }\n    product( other: Vector ) { return new Vector( this.x * other.x, this.y * other.y ) }\n    scale( other: number ) { return new Vector( this.x * other, this.y * other ) }\n    floor() { return new Vector( Math.floor( this.x ), Math.floor( this.y ) ) }\n    ceil() { return new Vector( Math.ceil( this.x ), Math.ceil( this.y ) ) }\n    distance( other: Vector ) { return this.subtract( other ).length }\n    equals( other: Vector | null ) {\n        if ( other == null ) return false\n        return equals( this.x, other.x ) && equals( this.y, other.y )\n    }\n    signs() {\n        return new Vector(Math.sign(this.x), Math.sign(this.y))\n    }\n    lerp( other: Vector, alpha: number ) {\n        let beta = 1 - alpha\n        return new Vector( this.x * beta + other.x * alpha, this.y * beta + other.y * alpha )\n    }\n    get length() {\n        let dist = Math.sqrt( this.x ** 2 + this.y ** 2 )\n        return dist\n    }\n    toString() {\n        return this.x + \",\" + this.y\n    }\n\n    unit() {\n        return this.scale( 1 / this.length )\n    }\n\n    clampLength( min, max ) {\n        let length = this.length\n        let unit = this.scale( 1 / length )\n        length = clamp( min, max, length )\n        return unit.scale( length )\n    }\n\n    static lissajous( t, xFreq, yFreq, xAmplitude = 1, yAmplitude = xAmplitude, xPhase = 0, yPhase = 0 ) {\n        return new Vector(\n            Math.cos( Math.PI * 2 * ( t + xPhase ) * xFreq ) * xAmplitude,\n            Math.sin( Math.PI * 2 * ( t + yPhase ) * yFreq ) * yAmplitude\n        )\n    }\n}\n","import { Vector } from \"./Vector\"\n\nconst epsilon = 0.000001\n\nexport default class Matrix {\n    readonly m11 = 0; readonly m12 = 0; readonly m13 = 0\n    readonly m21 = 0; readonly m22 = 0; readonly m23 = 0\n    readonly m31 = 0; readonly m32 = 0; readonly m33 = 0\n\n    static identity = new Matrix(\n        1, 0, 0,\n        0, 1, 0,\n        0, 0, 1\n    )\n\n    constructor(\n        m11, m12, m13,\n        m21, m22, m23,\n        m31, m32, m33\n    ) {\n        this.m11 = m11; this.m12 = m12; this.m13 = m13\n        this.m21 = m21; this.m22 = m22; this.m23 = m23\n        this.m31 = m31; this.m32 = m32; this.m33 = m33\n    }\n\n    multiply( other: Matrix ): Matrix { return multiplyMatrix( this, other, Matrix ) }\n    inverse(): Matrix { return inverse( this, Matrix ) }\n    determinant(): number { return determinant( this, Matrix ) }\n    equals( other: Matrix ): boolean { return equals( this, other, epsilon, Matrix ) }\n\n    multiplyVec( v: Vector, z: number = 1 ) {\n        let {\n            m11, m12, m13,\n            m21, m22, m23,\n        } = this\n        let { x, y } = v\n        return new Vector(\n            m11 * x + m12 * y + m13 * z,\n            m21 * x + m22 * y + m23 * z,\n        )\n    }\n\n    static translation( x = 0, y = 0 ) {\n        return new Matrix(\n            1, 0, x,\n            0, 1, y,\n            0, 0, 1\n        )\n    }\n\n    translate( x = 0, y = 0 ) {\n        return this.multiply( Matrix.translation( x, y ) )\n    }\n\n    static vTranslation( v: Vector ) {\n        return new Matrix(\n            1, 0, v.x,\n            0, 1, v.y,\n            0, 0, 1\n        )\n    }\n\n    vTranslate( v: Vector ) {\n        return this.multiply( Matrix.vTranslation( v ) )\n    }\n\n    static rotation( angle = 0 ) {\n        let s = Math.sin( angle )\n        let c = Math.cos( angle )\n        return new Matrix(\n            c, -s, 0,\n            s, c, 0,\n            0, 0, 1\n        )\n    }\n\n    rotate( angle = 0 ) {\n        return this.multiply( Matrix.rotation( angle ) )\n    }\n\n    static scale( x = 1, y = 1 ) {\n        return new Matrix(\n            x, 0, 0,\n            0, y, 0,\n            0, 0, 1\n        )\n    }\n\n    scale( x = 1, y = 1 ) {\n        return this.multiply( Matrix.scale( x, y ) )\n    }\n\n    // https://en.wikipedia.org/wiki/Transformation_matrix#Affine_transformations\n    static transformation( preTranslationX, preTranslationY, angle, scaleX, scaleY, translationX, translationY ) {\n        let px = preTranslationX, py = preTranslationY\n        let a = angle\n        let sx = scaleX\n        let sy = scaleY\n        let x = translationX\n        let y = translationY\n        let s = Math.sin( a ), c = Math.cos( a )\n        return new Matrix(\n            sx * c, -sy * s, px * sx * c - py * sy * s + x,\n            sx * s, sy * c, px * sx * s + py * sy * c + y,\n            0, 0, 1\n        )\n    }\n\n    static scaleAndTranslate( scale, translationX, translationY ) {\n        let s = scale\n        let x = translationX\n        let y = translationY\n        return new Matrix(\n            s, 0, x,\n            0, s, y,\n            0, 0, 1\n        )\n    }\n\n    print() {\n        let {\n            m11, m12, m13,\n            m21, m22, m23,\n            m31, m32, m33,\n        } = this\n        let rows = [\n            [ m11, m12, m13 ],\n            [ m21, m22, m23 ],\n            [ m31, m32, m33 ],\n        ]\n        let columnWidths = [\n            [ m11, m21, m31 ],\n            [ m12, m22, m32 ],\n            [ m13, m23, m33 ],\n        ].map(\n            column =>\n                column.map(\n                    e => e.toString().length\n                ).reduce(\n                    ( a, b ) => Math.max( a, b )\n                )\n        )\n        let pad = ( n: number, column: number ) => n.toString().padStart( columnWidths[ column ] )\n        let result = rows.map(\n            row => \"| \" + row.map( pad ).join( \"  \" ) + \" |\"\n        ).join( \"\\n\" )\n        console.log( result )\n    }\n\n}\n\n// Code generation:\n\n// function* rangeGen( n ) { for ( let i = 1; i <= n; i++ ) yield i }\n// function range( n ) { return Array.from( rangeGen( n ) ) }\nfunction range( n ) {\n    let res = [] as number[]\n    for ( let i = 1; i <= n; i++ ) res.push( i )\n    return res\n}\n\nfunction determinant2(\n    a11, a12,\n    a21, a22\n) {\n    return \"( \" + a11 + \" * \" + a22 + \" - \" + a12 + \" * \" + a21 + \" )\"\n}\n\nfunction determinant3( args: string[] ) {\n    let [\n        a11, a12, a13,\n        a21, a22, a23,\n        a31, a32, a33\n    ] = args\n    return `(${ a11 } * ${ determinant2( a22, a23, a32, a33 ) } -\n    ${ a12 } * ${ determinant2( a21, a23, a31, a33 ) } +\n    ${ a13 } * ${ determinant2( a21, a22, a31, a32 ) })`\n}\n\nfunction destructureMatrix( name: string ) {\n    let destructureArgs = range( 3 ).map(\n        j => range( 3 ).map(\n            i => \"m\" + j + i + \": \" + name + j + i\n        ).join( \", \" )\n    ).join( \",\\n    \" )\n    return \"let {\\n    \" + destructureArgs + \"\\n} = \" + name\n}\n\nconst determinant = ( () => {\n    let args = range( 3 ).map( ( j ) => range( 3 ).map( ( i ) => \"A.m\" + j + i ) ).flat()\n    let body = \"return \" + determinant3( args )\n    return new Function( \"A\", \"Matrix3\", body )\n} )()\n\nconst multiplyMatrix = ( () => {\n    let destructureA = destructureMatrix( \"A\" )\n    let destructureB = destructureMatrix( \"B\" )\n    let matrixArgs = range( 3 ).map(\n        j => range( 3 ).map(\n            i => range( 3 ).map(\n                k => \"A\" + j + k + \" * B\" + k + i\n            ).join( \" + \" )\n        ).join( \", \" )\n    ).join( \",\\n    \" )\n    let body = [\n        destructureA,\n        destructureB,\n        `return new Matrix3(\\n    ${ matrixArgs }\\n)`\n    ].join( \"\\n\" )\n    return new Function( \"A\", \"B\", \"Matrix3\", body )\n} )()\n\n// https://en.wikipedia.org/wiki/Cramer%27s_rule#Finding_inverse_matrix\n// https://en.wikipedia.org/wiki/Adjugate_matrix#3_%C3%97_3_generic_matrix\nconst inverse = ( () => {\n    let destructure = destructureMatrix( \"A\" )\n\n    let detArgs = range( 3 ).map( ( j ) => range( 3 ).map( ( i ) => \"A\" + j + i ) ).flat()\n    let coefStatemnent = \"let c = 1 / \" + determinant3( detArgs )\n\n    let det2 = ( a, b, c, d ) => determinant2( \"A\" + a, \"A\" + b, \"A\" + c, \"A\" + d )\n    // Adjugate matrix:\n    let b11 = det2( 22, 23, 32, 33 ), b12 = \"-\" + det2( 12, 13, 32, 33 ), b13 = det2( 12, 13, 22, 23 )\n    let b21 = \"-\" + det2( 21, 23, 31, 33 ), b22 = det2( 11, 13, 31, 33 ), b23 = \"-\" + det2( 11, 13, 21, 23 )\n    let b31 = det2( 21, 22, 31, 32 ), b32 = \"-\" + det2( 11, 12, 31, 32 ), b33 = det2( 11, 12, 21, 22 )\n\n    let matrixArgs = [\n        [ b11, b12, b13 ],\n        [ b21, b22, b23 ],\n        [ b31, b32, b33 ]\n    ].map( row => row.map( e => e + \" * c\" ).join( \", \" ) ).join( \",\\n    \" )\n\n    let body = [\n        destructure,\n        coefStatemnent,\n        `\\nreturn new Matrix3(${ matrixArgs })`\n    ].join( \"\\n\" )\n    return new Function( \"A\", \"Matrix3\", body )\n} )()\n\nconst equals = ( () => {\n    let destructureA = destructureMatrix( \"A\" )\n    let destructureB = destructureMatrix( \"B\" )\n    let comparisons = range( 3 ).map(\n        j => range( 3 ).map(\n            i => {\n                let index = j.toString() + i.toString()\n                return `if (Math.abs(A${ index } - B${ index }) > epsilon) return false`\n            }\n        )\n    ).flat()\n    let body = [\n        destructureA,\n        destructureB,\n        ...comparisons,\n        \"return true\"\n    ].join( \"\\n\" )\n    return new Function( \"A\", \"B\", \"epsilon\", \"Matrix3\", body )\n} )()","export function getImg( src: string ) {\n    let result = new Image()\n    result.src = src\n    return result\n}\n\nexport function randomColor() {\n    let nums = [\n        ( Math.random() * 256 ) | 0,\n        ( Math.random() * 256 ) | 0,\n        ( Math.random() * 256 ) | 0,\n    ]\n    return \"#\" + nums.map( x => x.toString( 16 ).padStart( 2, \"0\" ) ).join( \"\" )\n}\n\nexport function getFrameNumber( fps: number, numberOfFrames = Infinity, time = performance.now() / 1000 ) {\n    return Math.floor( time * fps ) % numberOfFrames\n}\n\nexport function arrayArgMin<T>( array: T[], func: ( T ) => number ) {\n    let minElem: T | null = null\n    let minValue = Infinity\n    let minIndex: number | null = null\n    for ( let i = 0; i < array.length; i++ ) {\n        let elem = array[ i ]\n        let value = func( elem )\n        if ( value < minValue ) {\n            minElem = elem\n            minValue = value\n            minIndex = i\n        }\n    }\n    return { element: minElem, value: minValue, index: minIndex }\n}","import Card from \"../gameobjects/card/Card\"\nimport { Vector } from \"../math/Vector\"\n\nexport default class Graphics {\n    static instance: Graphics\n    canvas: HTMLCanvasElement\n    c: CanvasRenderingContext2D\n    size!: Vector\n    constructor() {\n        Graphics.instance = this\n        this.canvas = <HTMLCanvasElement>document.getElementById( \"canvas1\" )\n        this.c = this.canvas.getContext( \"2d\" ) as CanvasRenderingContext2D\n        this.onResize()\n    }\n\n    onResize() {\n        let { canvas } = this\n        let rect = canvas.getBoundingClientRect()\n        canvas.width = rect.width\n        canvas.height = rect.height\n        this.size = new Vector( this.canvas.width, this.canvas.height )\n    }\n\n    vTranslate( v: Vector ) {\n        this.c.translate( v.x, v.y )\n    }\n\n    drawRect( pos: Vector, size: Vector, color: string = \"red\" ) {\n        this.c.fillStyle = color\n        this.c.fillRect( pos.x, pos.y, size.x, size.y )\n    }\n    drawRoundRect( pos: Vector, size: Vector, color: string = \"black\", radius: number ) {\n        this.c.fillStyle = color\n        this.c.beginPath()\n\n        this.c.moveTo(pos.x + radius, pos.y)\n        this.c.arcTo( pos.x + size.x, pos.y, pos.x + size.x, pos.y + size.y, radius )\n        this.c.arcTo( pos.x + size.x, pos.y + size.y, pos.x, pos.y + size.y, radius )\n        this.c.arcTo( pos.x, pos.y + size.y, pos.x, pos.y, radius )\n        this.c.arcTo( pos.x, pos.y, pos.x + size.x, pos.y, radius )\n        this.c.closePath()\n        this.c.fill()\n    }\n    strokeRect( pos: Vector, size: Vector, color: string = \"black\" ) {\n        this.c.strokeStyle = color\n        this.c.beginPath()\n        this.c.strokeRect( pos.x, pos.y, size.x, size.y )\n    }\n    strokeCircle( pos: Vector, radius: number, color: string = \"black\" ) {\n        this.c.beginPath()\n        this.c.arc(pos.x, pos.y, radius, 0, 2 * Math.PI)\n        this.c.strokeStyle = color\n        this.c.stroke()\n    }\n    fillCircle( pos: Vector, radius: number, color: string = \"black\" ) {\n        this.c.beginPath()\n        this.c.arc(pos.x, pos.y, radius, 0, 2 * Math.PI)\n        this.c.fillStyle = color\n        this.c.fill()\n    }\n    drawPip( pos:Vector, dim:Vector, fill:string = \"white\", stroke:string = \"black\") {\n        this.drawRect(pos, dim, fill)\n        this.strokeRect(pos, dim, stroke)\n    }\n    pipBlock( pos:Vector, dim:Vector, value:number, radix:number, vertical=false, fill = \"white\", empty = \"black\") {\n        //divide dim by radix+1\n        let pipDim = dim\n        if ( vertical ) {\n            pipDim.y = pipDim.y / (radix+1)\n        } else {\n            pipDim.x = pipDim.x / (radix+1)\n        }\n        let buffer = pipDim.scale(1/(radix-1))\n        this.c.lineWidth = 0.1\n        for ( let i = 0; i < radix; i++ ) {\n        //     //start at pos\n            let pipPos = pos\n            if ( vertical ) {\n                pipPos = pipPos.add(new Vector(0, pipDim.y*i+buffer.y*i))\n            } else {\n                pipPos = pipPos.add(new Vector(buffer.x*i+pipDim.x*i, 0))\n            }\n            if (i < value) {\n                this.drawPip(pipPos, pipDim, fill, \"black\")\n            } else {\n                this.drawPip(pipPos, pipDim, empty)\n            }\n        }\n    }\n    costDisplay(pos: Vector, cost: string, color1: string, color2: string, fontSize = 10 ) {\n        // this.drawRect(pos, dim, this.type.color)\n        this.drawRect(pos.add(new Vector(1.5, 1)), new Vector(7, 8), color2)\n        this.setFont(fontSize, \"pixel2\")\n        this.drawText(pos.add(new Vector(1.5, 1)), cost, color1)\n    }\n\n    makePath( path: Vector[] ) {\n        if ( path.length == 0 )\n            return\n        this.c.beginPath()\n        this.c.moveTo( path[ 0 ].x, path[ 0 ].y )\n        for ( let i = 1; i < path.length; i++ )\n            this.c.lineTo( path[ i ].x, path[ i ].y )\n    }\n\n    setFont( size: number, font: string ) {\n        this.c.font = size + \"px \" + font\n    }\n\n    textDimensions( text: string ) {\n        let metrics = this.c.measureText( text )\n        return new Vector( metrics.width, metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent )\n    }\n\n    drawText( pos: Vector, text: string, color: string,  options?: { padding?: number, boxColor?: string, alignX?: TextAlignX, alignY?: TextAlignY } ) {\n        let padding = options?.padding ?? 1\n        let textColor = color ?? \"white\"\n        let boxColor = options?.boxColor ?? \"black\"\n        let alignX = options?.alignX ?? TextAlignX.left\n        let alignY = options?.alignY ?? TextAlignY.top\n\n        let metrics = this.c.measureText( text )\n\n        let p = padding, p2 = padding * 2\n        let textDims = new Vector( metrics.width, metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent )\n        let textBoxDims = textDims.addXY( p2, p2 )\n        let textBoxOffset = pos.addXY( -textBoxDims.x * alignX, -textBoxDims.y * alignY )\n        let textOffset = textBoxOffset.addXY( p, p + metrics.actualBoundingBoxAscent )\n        this.c.fillStyle = textColor\n        this.c.fillText( text, textOffset.x, textOffset.y )\n\n        return textBoxDims\n    }\n\n    drawTextBox( pos: Vector, text: string, options: { padding?: number, textColor?: string, boxColor?: string, alignX?: TextAlignX, alignY?: TextAlignY } ) {\n        let padding = options.padding ?? 1\n        let textColor = options.textColor ?? \"white\"\n        let boxColor = options.boxColor ?? \"black\"\n        let alignX = options.alignX ?? TextAlignX.left\n        let alignY = options.alignY ?? TextAlignY.top\n\n        let metrics = this.c.measureText( text )\n\n        let p = padding, p2 = padding * 2\n        let textDims = new Vector( metrics.width, metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent )\n        let textBoxDims = textDims.addXY( p2, p2 )\n        let textBoxOffset = pos.addXY( -textBoxDims.x * alignX, -textBoxDims.y * alignY )\n        let textOffset = textBoxOffset.addXY( p, p + metrics.actualBoundingBoxAscent )\n        this.drawRect( textBoxOffset, textBoxDims, boxColor )\n        this.drawText( textOffset, text, textColor )\n\n        return textBoxDims\n    }\n\n    drawRoundTextBox( pos: Vector, text: string, options: { padding?: number, textColor?: string, boxColor?: string, alignX?: TextAlignX, alignY?: TextAlignY, borderRadius?: number } ) {\n        let padding = options.padding ?? 1\n        let textColor = options.textColor ?? \"white\"\n        let boxColor = options.boxColor ?? \"black\"\n        let alignX = options.alignX ?? TextAlignX.left\n        let alignY = options.alignY ?? TextAlignY.top\n        let borderRadius = options.borderRadius ?? 0\n\n        let metrics = this.c.measureText( text )\n\n        let p = padding, p2 = padding * 2\n        let textDims = new Vector( metrics.width, metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent )\n        let textBoxDims = textDims.addXY( p2, p2 )\n        let textBoxOffset = pos.addXY( -textBoxDims.x * alignX, -textBoxDims.y * alignY )\n        let textOffset = textBoxOffset.addXY( p, p + metrics.actualBoundingBoxAscent )\n        this.drawRoundRect( textBoxOffset, textBoxDims, boxColor, borderRadius )\n        this.drawText( textOffset, text, textColor )\n\n        return textBoxDims\n    }\n    drawSheetFrame( img: HTMLImageElement, frameHeight: number, x: number, y: number, frame: number ) {\n        let w = img.width\n        let h = frameHeight\n        this.c.drawImage( img, 0, h * frame, w, h, x, y, w, h )\n    }\n}\n\nexport enum TextAlignX { left = 0, center = .5, right = 1 }\nexport enum TextAlignY { top = 0, center = .5, bottom = 1 }","import Graphics from \"../../common/Graphics\"\n\n// An instance of Tile does not represent an individual tile on the map.\n// Each instance of Tile represents a type of tile.\nexport default abstract class Tile {\n    readonly name: string\n    constructor( options: { name: string } ) { this.name = options.name }\n    abstract getTraversalCost(): number\n    abstract getElevation(): number\n    abstract render( x: number, y: number ): void\n}\n\nexport class BasicTile extends Tile {\n    readonly traversalCost: number\n    readonly elevation: number\n    readonly texture: HTMLImageElement\n    constructor( options: { name: string, traversalCost: number, elevation: number, texture: HTMLImageElement } ) {\n        super( options )\n        this.traversalCost = options.traversalCost\n        this.elevation = options.elevation\n        this.texture = options.texture\n    }\n    getTraversalCost(): number { return this.traversalCost }\n    getElevation(): number { return this.elevation }\n    render( x: number, y: number ): void {\n        let c = Graphics.instance.c\n        c.save()\n        c.translate(0, 0)\n        c.drawImage( this.texture, x, y )\n        c.restore()\n    }\n}","import { getImg } from \"../../common/utils\"\nimport { BasicTile } from \"./Tile\"\n\n// export const Grass = new BasicTile( {\n//     name: \"grass\", traversalCost: 1, elevation: 0, texture: getImg( require( \"../www/images/tiles/flat/grass.png\" ) )\n// } )\nexport const Grass = new BasicTile( {\n    name: \"grass\", traversalCost: 1, elevation: 0, texture: getImg( require( \"../../www/images/tiles/iso/grassFlipped.png\" ) )\n} )\nexport const GrassHill = new BasicTile( {\n    name: \"grassHill\", traversalCost: Infinity, elevation: 1, texture: getImg( require( \"../../www/images/tiles/flat/hill5.png\" ) )\n} )\nexport const WaterShallow = new BasicTile( {\n    name: \"waterShallow\", traversalCost: Infinity, elevation: -1, texture: getImg( require( \"../../www/images/tiles/flat/ShallowWater.png\" ) )\n} )\nexport const WaterDeep = new BasicTile( {\n    name: \"waterDeep\", traversalCost: Infinity, elevation: -2, texture: getImg( require( \"../../www/images/tiles/flat/DeepWater.png\" ) )\n} )\nexport const AncientMech = new BasicTile( {\n    name: \"ancientMech\", traversalCost: Infinity, elevation: 1, texture: getImg( require( \"../../www/images/tiles/flat/ancientMech.png\" ) )\n} )\n","/*\n * A fast javascript implementation of simplex noise by Jonas Wagner\n\nBased on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.\nWhich is based on example code by Stefan Gustavson (stegu@itn.liu.se).\nWith Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\nBetter rank ordering method by Stefan Gustavson in 2012.\n\n Copyright (c) 2021 Jonas Wagner\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n */\n\nconst F2 = 0.5 * (Math.sqrt(3.0) - 1.0);\nconst G2 = (3.0 - Math.sqrt(3.0)) / 6.0;\nconst F3 = 1.0 / 3.0;\nconst G3 = 1.0 / 6.0;\nconst F4 = (Math.sqrt(5.0) - 1.0) / 4.0;\nconst G4 = (5.0 - Math.sqrt(5.0)) / 20.0;\n\nconst grad3 = new Float32Array([1, 1, 0,\n  -1, 1, 0,\n  1, -1, 0,\n\n  -1, -1, 0,\n  1, 0, 1,\n  -1, 0, 1,\n\n  1, 0, -1,\n  -1, 0, -1,\n  0, 1, 1,\n\n  0, -1, 1,\n  0, 1, -1,\n  0, -1, -1]);\n\nconst grad4 = new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,\n  0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,\n  1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,\n  -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,\n  1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,\n  -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,\n  1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,\n  -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]);\n\n/**\n * A random() function, must return a numer in the interval [0,1), just like Math.random().\n */ \nexport type RandomFn = () => number;\n\n/** Deterministic simplex noise generator suitable for 2D, 3D and 4D spaces. */\nexport class SimplexNoise {\n  private p: Uint8Array;\n  private perm: Uint8Array;\n  private permMod12: Uint8Array;\n  /**\n   * Creates a new `SimplexNoise` instance.\n   * This involves some setup. You can save a few cpu cycles by reusing the same instance.\n   * @param randomOrSeed A random number generator or a seed (string|number).\n   * Defaults to Math.random (random irreproducible initialization).\n   */\n  constructor(randomOrSeed: RandomFn|string|number = Math.random) {\n    const random = typeof randomOrSeed == 'function' ? randomOrSeed : alea(randomOrSeed);\n    this.p = buildPermutationTable(random);\n    this.perm = new Uint8Array(512);\n    this.permMod12 = new Uint8Array(512);\n    for (let i = 0; i < 512; i++) {\n      this.perm[i] = this.p[i & 255];\n      this.permMod12[i] = this.perm[i] % 12;\n    }\n  }\n\n  /**\n   * Samples the noise field in 2 dimensions\n   * @param x\n   * @param y \n   * @returns a number in the interval [-1, 1]\n   */\n  noise2D(x: number, y: number): number {\n    const permMod12 = this.permMod12;\n    const perm = this.perm;\n    let n0 = 0; // Noise contributions from the three corners\n    let n1 = 0;\n    let n2 = 0;\n    // Skew the input space to determine which simplex cell we're in\n    const s = (x + y) * F2; // Hairy factor for 2D\n    const i = Math.floor(x + s);\n    const j = Math.floor(y + s);\n    const t = (i + j) * G2;\n    const X0 = i - t; // Unskew the cell origin back to (x,y) space\n    const Y0 = j - t;\n    const x0 = x - X0; // The x,y distances from the cell origin\n    const y0 = y - Y0;\n    // For the 2D case, the simplex shape is an equilateral triangle.\n    // Determine which simplex we are in.\n    let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n    if (x0 > y0) {\n      i1 = 1;\n      j1 = 0;\n    } // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n    else {\n      i1 = 0;\n      j1 = 1;\n    } // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n    // c = (3-sqrt(3))/6\n    const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n    const y1 = y0 - j1 + G2;\n    const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n    const y2 = y0 - 1.0 + 2.0 * G2;\n    // Work out the hashed gradient indices of the three simplex corners\n    const ii = i & 255;\n    const jj = j & 255;\n    // Calculate the contribution from the three corners\n    let t0 = 0.5 - x0 * x0 - y0 * y0;\n    if (t0 >= 0) {\n      const gi0 = permMod12[ii + perm[jj]] * 3;\n      t0 *= t0;\n      n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient\n    }\n    let t1 = 0.5 - x1 * x1 - y1 * y1;\n    if (t1 >= 0) {\n      const gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;\n      t1 *= t1;\n      n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);\n    }\n    let t2 = 0.5 - x2 * x2 - y2 * y2;\n    if (t2 >= 0) {\n      const gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;\n      t2 *= t2;\n      n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 70.0 * (n0 + n1 + n2);\n  }\n\n  /**\n   * Samples the noise field in 3 dimensions\n   * @param x \n   * @param y \n   * @param z \n   * @returns a number in the interval [-1, 1]\n   */\n  noise3D(x:number, y:number, z:number): number {\n    const permMod12 = this.permMod12;\n    const perm = this.perm;\n    let n0, n1, n2, n3; // Noise contributions from the four corners\n    // Skew the input space to determine which simplex cell we're in\n    const s = (x + y + z) * F3; // Very nice and simple skew factor for 3D\n    const i = Math.floor(x + s);\n    const j = Math.floor(y + s);\n    const k = Math.floor(z + s);\n    const t = (i + j + k) * G3;\n    const X0 = i - t; // Unskew the cell origin back to (x,y,z) space\n    const Y0 = j - t;\n    const Z0 = k - t;\n    const x0 = x - X0; // The x,y,z distances from the cell origin\n    const y0 = y - Y0;\n    const z0 = z - Z0;\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n    // Determine which simplex we are in.\n    let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n    let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n    if (x0 >= y0) {\n      if (y0 >= z0) {\n        i1 = 1;\n        j1 = 0;\n        k1 = 0;\n        i2 = 1;\n        j2 = 1;\n        k2 = 0;\n      } // X Y Z order\n      else if (x0 >= z0) {\n        i1 = 1;\n        j1 = 0;\n        k1 = 0;\n        i2 = 1;\n        j2 = 0;\n        k2 = 1;\n      } // X Z Y order\n      else {\n        i1 = 0;\n        j1 = 0;\n        k1 = 1;\n        i2 = 1;\n        j2 = 0;\n        k2 = 1;\n      } // Z X Y order\n    }\n    else { // x0<y0\n      if (y0 < z0) {\n        i1 = 0;\n        j1 = 0;\n        k1 = 1;\n        i2 = 0;\n        j2 = 1;\n        k2 = 1;\n      } // Z Y X order\n      else if (x0 < z0) {\n        i1 = 0;\n        j1 = 1;\n        k1 = 0;\n        i2 = 0;\n        j2 = 1;\n        k2 = 1;\n      } // Y Z X order\n      else {\n        i1 = 0;\n        j1 = 1;\n        k1 = 0;\n        i2 = 1;\n        j2 = 1;\n        k2 = 0;\n      } // Y X Z order\n    }\n    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n    // c = 1/6.\n    const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n    const y1 = y0 - j1 + G3;\n    const z1 = z0 - k1 + G3;\n    const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\n    const y2 = y0 - j2 + 2.0 * G3;\n    const z2 = z0 - k2 + 2.0 * G3;\n    const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\n    const y3 = y0 - 1.0 + 3.0 * G3;\n    const z3 = z0 - 1.0 + 3.0 * G3;\n    // Work out the hashed gradient indices of the four simplex corners\n    const ii = i & 255;\n    const jj = j & 255;\n    const kk = k & 255;\n    // Calculate the contribution from the four corners\n    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n    if (t0 < 0) n0 = 0.0;\n    else {\n      const gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;\n      t0 *= t0;\n      n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);\n    }\n    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n    if (t1 < 0) n1 = 0.0;\n    else {\n      const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;\n      t1 *= t1;\n      n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);\n    }\n    let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n    if (t2 < 0) n2 = 0.0;\n    else {\n      const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;\n      t2 *= t2;\n      n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);\n    }\n    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n    if (t3 < 0) n3 = 0.0;\n    else {\n      const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;\n      t3 *= t3;\n      n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to stay just inside [-1,1]\n    return 32.0 * (n0 + n1 + n2 + n3);\n  }\n\n  /**\n   * Samples the noise field in 4 dimensions\n   * @param x \n   * @param y \n   * @param z \n   * @returns a number in the interval [-1, 1]\n   */\n  noise4D(x:number, y:number, z:number, w:number): number {\n    const perm = this.perm;\n\n    let n0, n1, n2, n3, n4; // Noise contributions from the five corners\n    // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n    const s = (x + y + z + w) * F4; // Factor for 4D skewing\n    const i = Math.floor(x + s);\n    const j = Math.floor(y + s);\n    const k = Math.floor(z + s);\n    const l = Math.floor(w + s);\n    const t = (i + j + k + l) * G4; // Factor for 4D unskewing\n    const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n    const Y0 = j - t;\n    const Z0 = k - t;\n    const W0 = l - t;\n    const x0 = x - X0; // The x,y,z,w distances from the cell origin\n    const y0 = y - Y0;\n    const z0 = z - Z0;\n    const w0 = w - W0;\n    // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n    // To find out which of the 24 possible simplices we're in, we need to\n    // determine the magnitude ordering of x0, y0, z0 and w0.\n    // Six pair-wise comparisons are performed between each possible pair\n    // of the four coordinates, and the results are used to rank the numbers.\n    let rankx = 0;\n    let ranky = 0;\n    let rankz = 0;\n    let rankw = 0;\n    if (x0 > y0) rankx++;\n    else ranky++;\n    if (x0 > z0) rankx++;\n    else rankz++;\n    if (x0 > w0) rankx++;\n    else rankw++;\n    if (y0 > z0) ranky++;\n    else rankz++;\n    if (y0 > w0) ranky++;\n    else rankw++;\n    if (z0 > w0) rankz++;\n    else rankw++;\n    // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n    // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n    // impossible. Only the 24 indices which have non-zero entries make any sense.\n    // We use a thresholding to set the coordinates in turn from the largest magnitude.\n    // Rank 3 denotes the largest coordinate.\n    // Rank 2 denotes the second largest coordinate.\n    // Rank 1 denotes the second smallest coordinate.\n\n    // The integer offsets for the second simplex corner\n    const i1 = rankx >= 3 ? 1 : 0;\n    const j1 = ranky >= 3 ? 1 : 0;\n    const k1 = rankz >= 3 ? 1 : 0;\n    const l1 = rankw >= 3 ? 1 : 0;\n    // The integer offsets for the third simplex corner\n    const i2 = rankx >= 2 ? 1 : 0;\n    const j2 = ranky >= 2 ? 1 : 0;\n    const k2 = rankz >= 2 ? 1 : 0;\n    const l2 = rankw >= 2 ? 1 : 0;\n\n    // The integer offsets for the fourth simplex corner\n    const i3 = rankx >= 1 ? 1 : 0;\n    const j3 = ranky >= 1 ? 1 : 0;\n    const k3 = rankz >= 1 ? 1 : 0;\n    const l3 = rankw >= 1 ? 1 : 0;\n    // The fifth corner has all coordinate offsets = 1, so no need to compute that.\n    const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n    const y1 = y0 - j1 + G4;\n    const z1 = z0 - k1 + G4;\n    const w1 = w0 - l1 + G4;\n    const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\n    const y2 = y0 - j2 + 2.0 * G4;\n    const z2 = z0 - k2 + 2.0 * G4;\n    const w2 = w0 - l2 + 2.0 * G4;\n    const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\n    const y3 = y0 - j3 + 3.0 * G4;\n    const z3 = z0 - k3 + 3.0 * G4;\n    const w3 = w0 - l3 + 3.0 * G4;\n    const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\n    const y4 = y0 - 1.0 + 4.0 * G4;\n    const z4 = z0 - 1.0 + 4.0 * G4;\n    const w4 = w0 - 1.0 + 4.0 * G4;\n    // Work out the hashed gradient indices of the five simplex corners\n    const ii = i & 255;\n    const jj = j & 255;\n    const kk = k & 255;\n    const ll = l & 255;\n    // Calculate the contribution from the five corners\n    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\n    if (t0 < 0) n0 = 0.0;\n    else {\n      const gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;\n      t0 *= t0;\n      n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);\n    }\n    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\n    if (t1 < 0) n1 = 0.0;\n    else {\n      const gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;\n      t1 *= t1;\n      n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);\n    }\n    let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\n    if (t2 < 0) n2 = 0.0;\n    else {\n      const gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;\n      t2 *= t2;\n      n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);\n    }\n    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\n    if (t3 < 0) n3 = 0.0;\n    else {\n      const gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;\n      t3 *= t3;\n      n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);\n    }\n    let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\n    if (t4 < 0) n4 = 0.0;\n    else {\n      const gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;\n      t4 *= t4;\n      n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);\n    }\n    // Sum up and scale the result to cover the range [-1,1]\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n  }\n}\nexport default SimplexNoise;\n\n/**\n * Builds a random permutation table.\n * This is exported only for (internal) testing purposes.\n * Do not rely on this export.\n * @private\n */\nexport function buildPermutationTable(random: RandomFn): Uint8Array {\n  const p = new Uint8Array(256);\n  for (let i = 0; i < 256; i++) {\n    p[i] = i;\n  }\n  for (let i = 0; i < 255; i++) {\n    const r = i + ~~(random() * (256 - i));\n    const aux = p[i];\n    p[i] = p[r];\n    p[r] = aux;\n  }\n  return p;\n}\n\n/*\nThe ALEA PRNG and masher code used by simplex-noise.js\nis based on code by Johannes Baagøe, modified by Jonas Wagner.\nSee alea.md for the full license.\n*/\nfunction alea(seed: string|number): RandomFn {\n  let s0 = 0;\n  let s1 = 0;\n  let s2 = 0;\n  let c = 1;\n\n  const mash = masher();\n  s0 = mash(' ');\n  s1 = mash(' ');\n  s2 = mash(' ');\n\n  s0 -= mash(seed);\n  if (s0 < 0) {\n    s0 += 1;\n  }\n  s1 -= mash(seed);\n  if (s1 < 0) {\n    s1 += 1;\n  }\n  s2 -= mash(seed);\n  if (s2 < 0) {\n    s2 += 1;\n  }\n\n  return function() {\n    const t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\n    s0 = s1;\n    s1 = s2;\n    return s2 = t - (c = t | 0);\n  };\n}\n\nfunction masher() {\n  let n = 0xefc8249d;\n  return function(data: number|string) {\n    data = data.toString();\n    for (let i = 0; i < data.length; i++) {\n      n += data.charCodeAt(i);\n      let h = 0.02519603282416938 * n;\n      n = h >>> 0;\n      h -= n;\n      h *= n;\n      n = h >>> 0;\n      h -= n;\n      n += h * 0x100000000; // 2^32\n    }\n    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n  };\n}","import { Vector } from \"../../math/Vector\"\nimport Tile from \"./Tile\"\nimport * as Tiles from \"./Tiles\"\nconst { SimplexNoise } = require( 'simplex-noise' );\nimport Unit from \"../mech/Unit\"\n\nexport default class Grid {\n    private simplex = new SimplexNoise();\n    private content: Tile[]\n    width: number\n    height: number\n    constructor( width, height ) {\n        this.width = width\n        this.height = height\n        this.content = []\n        for ( let i = 0; i < width * height; i++ )\n            this.content.push( Tiles.Grass )\n    }\n    randomize( blockChance: number ) {\n        for ( let y = 0; y < this.height; y++ ) {\n            for ( let x = 0; x < this.width; x++ ) {\n                let isBlock = Math.random() < blockChance\n                if ( isBlock )\n                    this.setFromXY( x, y, Tiles.GrassHill )\n            }\n        }\n    }\n    randomize2( blockChance: number = 0.0 ) {\n\n        let zoom = 1;\n        let h = this.height;\n        let w = this.width;\n\n        //radial noise\n        let radius = 9 + Math.random();\n        let amplitude = 2.5 + ( 2 * Math.random() );\n        let rFreq = 2 / 64 + ( ( 6 / 64 ) * Math.random() );\n        let radius2 = radius + ( 1.5 * Math.random() );\n        let amplitude2 = .5 + ( 1.5 * Math.random() )\n        let rFreq2 = rFreq + ( ( 8 / 64 ) * Math.random() );\n        let symetric = false\n\n        //topical noise\n        let frequency = 1 / 8;\n        let mountaincutoff = .5;\n        let watercutoff = -.7;\n\n        for ( let x = 0; x < w; x++ ) {\n            for ( let y = 0; y < h; y++ ) {\n\n                let hyp = Math.hypot( ( y - ( h / 2 ) ), ( x - ( w / 2 ) ) )\n                let radialProjection = [ radius, 0 ];\n                let radialProjection2 = [ radius2, 0 ];\n\n                if ( hyp != 0 ) {\n                    let y1 = ( y - ( h / 2 ) )\n                    let x1 = ( x - ( w / 2 ) )\n                    y1 = y1 * ( radius / hyp )\n                    x1 = x1 * ( radius / hyp )\n                    y1 = y1 + ( h / 2 )\n                    x1 = x1 + ( w / 2 )\n                    radialProjection = [ x1, y1 ]\n                    let y2 = ( y - ( h / 2 ) )\n                    let x2 = ( x - ( w / 2 ) )\n                    y2 = y2 * ( radius2 / hyp )\n                    x2 = x2 * ( radius2 / hyp )\n                    y2 = y2 + ( h / 2 )\n                    x2 = x2 + ( w / 2 )\n                    radialProjection2 = [ x2, y2 ]\n                }\n\n                let radialTest = radius + ( amplitude * this.simplex.noise2D( radialProjection[ 0 ] * rFreq, radialProjection[ 1 ] * rFreq ) );\n                let radialTest2 = radius2 + ( amplitude2 * this.simplex.noise2D( radialProjection2[ 0 ] * rFreq2, radialProjection2[ 1 ] * rFreq2 ) );\n\n\n                if ( Math.hypot( ( x - ( w / 2 ) ), ( y - ( h / 2 ) ) ) > radialTest2 && Math.hypot( ( x - ( w / 2 ) ), ( y - ( h / 2 ) ) ) > radialTest ) {\n                    // console.log( `(${ x },${ y })=deep` )\n                    this.setFromXY( x, y, Tiles.WaterDeep )\n                }\n                else if ( Math.hypot( ( x - ( w / 2 ) ), ( y - ( h / 2 ) ) ) > radialTest ) {\n                    this.setFromXY( x, y, Tiles.WaterShallow )\n                }\n                else if ( this.simplex.noise2D( x * frequency, y * frequency ) > mountaincutoff ) {\n                    this.setFromXY( x, y, Tiles.GrassHill )\n                }\n                else if ( this.simplex.noise2D( x * frequency, y * frequency ) < watercutoff ) {\n                    this.setFromXY( x, y, Tiles.WaterShallow )\n                }\n                else {\n                    this.setFromXY( x, y, Tiles.Grass )\n                }\n            }\n        }\n    }\n    clearUnitPaths() {\n        //------------Not ideal Function to ensure Viability but will make every match playable\n        let { width, height } = this\n\n        let landingDim = new Vector(4, 4)\n        let buffer = new Vector(3, 3)\n        //clear upper left chunk\n        this.fillRect(buffer, landingDim, Tiles.Grass)\n        //clear lower right chunk\n        this.fillRect(new Vector(width, height).subtract(landingDim).subtract(buffer), landingDim, Tiles.Grass)\n\n        let limit = new Vector(width, height).subtract(buffer)\n        for (let i = buffer.x; i < limit.x || i < limit.y; i++) {\n            let pos = new Vector(i, i)\n            let bonusPos = new Vector(i+1, i)\n            this.set(pos, Tiles.Grass)\n            this.set(bonusPos, Tiles.Grass)\n        }\n    }\n    newMap() {\n        this.randomize2(0)\n        this.clearUnitPaths()\n    }\n    placeUnits( units: Unit[] ) {\n        for ( let iter = 0; iter < units.length; iter++ ) {\n            if ( units[ iter ].teamNumber == 0 ) {\n                //first half of units top left\n                this.placeUnit( units, units[ iter ], true )\n            }\n            else {//second half of units bottom right\n                this.placeUnit( units, units[ iter ], false )\n            }\n        }\n    }\n    placeUnit( units: Unit[], placing: Unit, player1: boolean ) {\n        let max = 0\n        if ( player1 ) {\n            max = this.height + this.width\n        }\n        for ( let y = 0; y < this.height; y++ ) {\n            for ( let x = 0; x < this.width; x++ ) {\n                let occupied = false;\n                units.forEach( unit => {\n                    if ( unit.pos.x == x && unit.pos.y == y ) {\n                        occupied = true;\n                    }\n                } );\n                if ( ( player1 ? ( x + y ) < max : ( x + y ) > max ) && !occupied && this.getFromXY( x, y ).getTraversalCost() < Infinity ) {\n                    max = x + y\n                    placing.pos.x = x\n                    placing.pos.y = y\n                }\n            }\n        }\n    }\n    set( pos: Vector, value ) {\n        this.setFromXY( pos.x, pos.y, value )\n    }\n    setFromXY( x: number, y: number, value ) {\n        if ( y >= this.height || x >= this.width ) {\n            console.error( \"Tried setting tile out of grid bounds.\" )\n            return\n        }\n        this.content[ y * this.width + x ] = value\n    }\n    get( pos: Vector ) {\n        return this.getFromXY( pos.x, pos.y )\n    }\n    getFromXY( x: number, y: number ) {\n        return this.content[ y * this.width + x ]\n    }\n    fillRect( pos: Vector, size: Vector, value: Tile ) {\n        let startX = Math.max( 0, pos.x )\n        let startY = Math.max( 0, pos.y )\n        let endX = Math.min( pos.x + size.x, this.width )\n        let endY = Math.min( pos.y + size.y, this.height )\n        for ( let y = startY; y < endY; y++ ) {\n            for ( let x = startX; x < endX; x++ ) {\n                this.setFromXY( x, y, value )\n            }\n        }\n    }\n    contains( pos: Vector ) {\n        return pos.y >= 0 && pos.x >= 0 && pos.x < this.width && pos.y < this.height\n    }\n    isEmpty( pos: Vector ) {\n        return this.get( pos ).getTraversalCost() < Infinity\n    }\n    getElevation( pos: Vector ) {\n        return this.get( pos )?.getElevation() ?? 0\n    }\n}","import { Vector } from \"../../math/Vector\"\nimport Match from \"../../stages/Match\"\n\nconst offsetOrderings = [\n    [ //  Horizontal-first ordering\n        new Vector( 1, 0 ), new Vector( -1, 0 ),\n        new Vector( 0, 1 ), new Vector( 0, -1 ),\n    ],\n    [ //  Vertical first ordering\n        new Vector( 0, 1 ), new Vector( 0, -1 ),\n        new Vector( 1, 0 ), new Vector( -1, 0 ),\n    ],\n]\nfunction getMoves( tilePairity: number, useDiagonals = false ) {\n    if ( useDiagonals )\n        return [\n            new Vector( 1, 0 ), new Vector( -1, 0 ),\n            new Vector( 0, 1 ), new Vector( 0, -1 ),\n\n            new Vector( 1, 1 ), new Vector( -1, 1 ),\n            new Vector( -1, -1 ), new Vector( 1, -1 ),\n        ]\n    else\n        return offsetOrderings[ tilePairity ]\n    //  Alternating between vertical-first and horizontal-first leads\n    //  to a preference for zigzagging paths over large L-shaped paths.\n}\n\nexport function findPath( match: Match, origin: Vector, destination: Vector, maxDepth = 100 ) {\n    type Node = { pos: Vector, parent: Node | null }\n    function makeNode( pos: Vector, parent: Node | null ): Node {\n        return { pos, parent }\n    }\n\n    function rebuildPath( node: Node ) {\n        let steps = [ node.pos ]\n        while ( node.parent != null ) {\n            node = node.parent\n            steps.push( node.pos )\n        }\n        return steps.reverse()\n    }\n\n    if ( origin.equals( destination ) )\n        return [ origin ]\n    if ( !match.isWalkable( destination ) )\n        return null\n\n    let destKey = destination.toString()\n\n    let currLayer = [ makeNode( origin, null ) ]\n    let nextLayer = [] as Node[]\n    let visited = new Set<string>()\n    visited.add( origin.toString() )\n\n    for ( let i = 0; i < maxDepth; i++ ) {\n        for ( let node of currLayer ) {\n            let pairity = ( node.pos.x + node.pos.y ) % 2\n            let offsets = getMoves( pairity )\n\n            for ( let offset of offsets ) {\n                let pos2 = node.pos.add( offset )\n                if ( !match.isWalkable( pos2 ) )\n                    continue\n                if ( Math.abs( offset.x ) > 0 && Math.abs( offset.y ) > 0 ) {\n                    // Check that diagonal move isn't between two obstacles.\n                    let freeAlongX = match.isWalkable( node.pos.addXY( offset.x, 0 ) )\n                    let freeAlongY = match.isWalkable( node.pos.addXY( 0, offset.y ) )\n                    if ( !freeAlongX && !freeAlongY )\n                        continue\n                }\n                let key = pos2.toString()\n                if ( visited.has( key ) )\n                    continue\n                visited.add( key )\n                let node2 = makeNode( pos2, node )\n\n                if ( key == destKey )\n                    return rebuildPath( node2 )\n\n                nextLayer.push( node2 )\n            }\n        }\n\n        let tmp = currLayer\n        currLayer = nextLayer\n        nextLayer = tmp\n        nextLayer.length = 0\n    }\n\n    return null\n}","import { contains } from \"../math/math\"\nimport Matrix from \"../math/Matrix\"\nimport { Vector } from \"../math/Vector\"\n\nexport interface SceneNode {\n    localMatrix: Matrix\n    children?: Iterable<SceneNode>\n    parent?: SceneNode\n    rect?: Rect\n    scalar?: number\n    // For adding child nodes.\n    content?: () => void\n    // Events\n    onClick?: ( node: SceneNode, pos: Vector ) => void\n    onRender?: ( node: SceneNode ) => void\n    onHover?: ( node: SceneNode, pos: Vector ) => void\n    onRenderPost?: ( node: SceneNode ) => void\n    // Debug fields\n    debugColor?: string\n    description?: string\n}\n\n//  Pickable geometry. Might generalize geometry and add z-sorting.\nexport type Rect = {\n    width: number\n    height: number\n}\n\nexport type PickingResult = {\n    node?: SceneNode\n    point: Vector // Coordinates of picking point in node's local space.\n}\n\nexport default class Scene {\n\n    static openNode?: SceneNode\n\n    static node( node: SceneNode ) {\n        let openNode = Scene.openNode\n        if ( openNode ) {\n            if ( !openNode.children )\n                openNode.children = []\n            if ( Array.isArray( openNode.children ) )\n                openNode.children.push( node )\n            node.parent = openNode\n        }\n        Scene.openNode = node\n        if ( node.content )\n            node.content()\n        Scene.openNode = node.parent\n        return node\n    }\n\n    static render( c: CanvasRenderingContext2D, node: SceneNode, debug = false ) {\n        let { m11, m12, m13, m21, m22, m23 } = node.localMatrix\n        c.save()\n        c.transform( m11, m21, m12, m22, m13, m23 )\n        if ( node.onRender )\n            node.onRender( node )\n        if ( debug && node.rect != null && node.debugColor != null ) {\n            c.globalAlpha = 0.25\n            c.fillStyle = node.debugColor\n            c.fillRect( 0, 0, node.rect.width, node.rect.height )\n            c.globalAlpha = 1\n        }\n        if ( node.children )\n            for ( let child of node.children )\n                Scene.render( c, child, debug )\n        if ( node.onRenderPost )\n            node.onRenderPost( node )\n        c.restore()\n    }\n\n    static pickNode( node: SceneNode, p: Vector ): SceneNode | undefined {\n        return Scene.pick( node, p ).node\n    }\n\n    static pick( node: SceneNode, p: Vector ): PickingResult {\n        let result: SceneNode | undefined\n        let point = p\n        function visitNode( node: SceneNode, p: Vector ) {\n            let p2 = node.localMatrix.inverse().multiplyVec( p )\n            if ( node.rect ) {\n                let rect = node.rect\n                if ( contains( 0, rect.width, p2.x ) && contains( 0, rect.height, p2.y ) ) {\n                    result = node\n                    point = p2\n                }\n            }\n            if ( node.children )\n                for ( let child of node.children )\n                    visitNode( child, p2 )\n        }\n        visitNode( node, p )\n        return { node: result, point }\n    }\n\n    static addParentReferences( node: SceneNode, parent?: SceneNode ) {\n        node.parent = parent\n        if ( node.children )\n            for ( let child of node.children )\n                Scene.addParentReferences( child, node )\n    }\n\n    static relativeMatrix( node: SceneNode, ancestor?: SceneNode ) {\n        let result = node.localMatrix\n        while ( node.parent && node != ancestor ) {\n            result = node.parent.localMatrix.multiply( result )\n            node = node.parent\n        }\n        return result\n    }\n\n    static globalMatrix( node: SceneNode ) {\n        return Scene.relativeMatrix( node )\n    }\n\n    static toLocalSpace( vector: Vector, node: SceneNode, ancestor?: SceneNode ) {\n        let matrix = Scene.relativeMatrix( node, ancestor )\n        return matrix.inverse().multiplyVec( vector )\n    }\n\n}\n","import Graphics from \"../../common/Graphics\";\nimport Scene, { SceneNode } from \"../../common/Scene\";\nimport Game from \"../../Game\";\nimport Match from \"../../stages/Match\";\nimport Matrix from \"../../math/Matrix\";\nimport { Vector } from \"../../math/Vector\";\nimport UnitTray from \"../ui/UnitTray\";\nimport { Chrome, Earth } from \"./RigTypes\";\nimport Unit from \"./Unit\";\n\nexport default class Team {\n    selectedUnitIndex = -1\n\n    name: string\n    flipUnits: boolean\n\n    units: Unit[] = []\n    playable = true\n\n    scene: SceneNode = { localMatrix: Matrix.identity }\n\n    constructor( name: string, units: Unit[], flip: boolean = false, teamNumber: number ) {\n        this.units = units\n        this.name = name\n        this.flipUnits = flip\n    }\n    get length() {\n        return this.units.length\n    }\n    get hasUnitSelected() {\n        return this.selectedUnitIndex > -1\n    }\n    //----DATA ACCESS----\n    setUnitIndex( index: number ) {\n        if ( index != this.selectedUnitIndex )\n            Game.instance.match.cardTray.deselect()\n        this.selectedUnitIndex = index\n        // this.onSelectUnit()\n    }\n\n    deselect() {\n        // this.hasUnitSelected = false\n        // this.index = -1\n        this.setUnitIndex( -1 )\n    }\n\n    toggleSelectIndex( index: number ) {\n        if ( this.hasUnitSelected && index == this.selectedUnitIndex ) {\n            this.deselect()\n            Game.instance.match.cardTray.deselect()\n        } else {\n            this.setUnitIndex( index )\n        }\n    }\n\n    toggleSelectUnit( unit: Unit ) {\n        let index = this.units.indexOf( unit )\n        this.toggleSelectIndex( index )\n    }\n\n    cycleUnits() {\n        if ( !this.hasUnitSelected ) {\n            this.setUnitIndex( 0 )\n        } else {\n            this.setUnitIndex( ( this.selectedUnitIndex + 1 ) % this.length )\n        }\n    }\n\n    selectUnit( unit: Unit ) {\n        let units = this.units\n        let index = units.indexOf( unit )\n        if ( index > -1 ) {\n            this.setUnitIndex( index )\n        }\n    }\n\n    selectedUnit() {\n        let units = this.units\n        if ( !this.hasUnitSelected ) return undefined\n        return units[ this.selectedUnitIndex ]\n    }\n    getUnit( pos: Vector ) {\n        for ( let unit of this.units )\n            if ( unit.pos.equals( pos ) )\n                return unit\n    }\n\n    endTurn() {\n        this.units.forEach(unit => {\n            //resets speed\n            unit.speed = unit.maxSpeed\n        })\n        this.deselect()\n    }\n    startTurn() {\n        this.units.forEach(unit => {\n            unit.energy = unit.maxEnergy\n            unit.statCap()\n        } )\n        this.deselect()\n    }\n\n    update() {\n        this.units = this.units.filter( unit => unit.health > 0 )\n        for ( let unit of this.units )\n            unit.update()\n    }\n\n}","import { getImg } from \"../../common/utils\"\nimport Game from \"../../Game\"\nimport Unit from \"../mech/Unit\"\nimport Match from \"../../stages/Match\"\nimport { Vector } from \"../../math/Vector\"\nimport { findPath } from \"../map/pathfinding\"\nimport * as Tiles from \"../map/Tiles\"\nimport Card from \"./Card\"\nimport Graphics from \"../../common/Graphics\"\nimport { randomFloor } from \"../../math/math\"\n//I have no idea why this requires one period but it does\n//Ores\nconst ore = getImg( require( \"../../www/images/cards/ore/pustule.png\" ) )\n\n//Action Icons\nconst blank = getImg( require( \"../../www/images/cards/backing/card.png\" ) )\n\nconst laser = getImg( require( \"../../www/images/cards/icon/laser.png\" ) )\nconst energyArmor = getImg( require( \"../../www/images/cards/icon/energyArmor.png\" ) )\nconst shieldCharge = getImg( require( \"../../www/images/cards/icon/shieldCharge.png\" ) )\nconst energyFist = getImg( require( \"../../www/images/cards/icon/energyFist.png\" ) )\nconst barrier = getImg( require( \"../../www/images/cards/icon/dead/barrier.png\" ) )\n// const chargeBeam = getImg( require( \"../../www/images/cards/icon/chargeBeam.png\" ) )\n\nconst boulder = getImg( require( \"../../www/images/cards/icon/boulder.png\" ) )\nconst mine = getImg( require( \"../../www/images/cards/icon/mine.png\" ) )\nconst gorge = getImg( require( \"../../www/images/cards/icon/gorge.png\" ) )\nconst blastCharge = getImg( require( \"../../www/images/cards/icon/blastCharge.png\" ) )\nconst dynamite = getImg( require( \"../../www/images/cards/icon/dynamite.png\" ) )\nconst plating = getImg( require( \"../../www/images/cards/icon/dead/plating.png\" ) )\n\nconst claw = getImg( require( \"../../www/images/cards/icon/claw.png\" ) )\nconst frendzi = getImg( require( \"../../www/images/cards/icon/frendzi.png\" ) )\nconst leap = getImg( require( \"../../www/images/cards/icon/leap.png\" ) )\nconst lump = getImg( require( \"../../www/images/cards/icon/lump.png\" ) )\nconst chomp = getImg( require( \"../../www/images/cards/icon/chomp.png\" ) )\nconst acid = getImg( require( \"../../www/images/cards/icon/acid.png\" ) )\nconst bloodClot = getImg( require( \"../../www/images/cards/icon/dead/bloodClot.png\" ) )\n\nconst sprint = getImg( require( \"../../www/images/cards/icon/sprint.png\" ) )\nconst repair = getImg( require( \"../../www/images/cards/icon/repair.png\" ) )\nconst grapplingHook = getImg( require( \"../../www/images/cards/icon/grapplingHook.png\" ) )\nconst rifle = getImg( require( \"../../www/images/cards/icon/gun.png\" ) )\n\nconst pollen = getImg( require( \"../../www/images/cards/icon/pollen.png\" ) )\nconst fruit = getImg( require( \"../../www/images/cards/icon/fruit.png\" ) )\nconst root = getImg( require( \"../../www/images/cards/icon/root.png\" ) )\nconst flower = getImg( require( \"../../www/images/cards/icon/flower.png\" ) )\nconst bark = getImg( require( \"../../www/images/cards/icon/dead/bark.png\" ) )\nconst fungus = getImg( require( \"../../www/images/cards/icon/fungus.png\" ) )\nconst boomShroom = getImg( require( \"../../www/images/cards/icon/boomShroom.png\" ) )\nconst worms = getImg( require( \"../../www/images/cards/icon/worms.png\" ) )\n\n\nconst jelly = getImg( require( \"../../www/images/cards/icon/jelly.png\" ) )\nconst tentacle = getImg( require( \"../../www/images/cards/icon/tentacle.png\" ) )\nconst warp = getImg( require( \"../../www/images/cards/icon/warp.png\" ) )\nconst frost = getImg( require( \"../../www/images/cards/icon/frost.png\" ) )\n\n\n//Card Background\nconst flesh = getImg( require( \"../../www/images/cards/backing/flesh.png\" ) )\nconst black = getImg( require( \"../../www/images/cards/backing/BlackCardBase.png\" ) )\nconst brown = getImg( require( \"../../www/images/cards/backing/BrownCardBase.png\" ) )\nconst green = getImg( require( \"../../www/images/cards/backing/jungle.png\" ) )\n// const green = getImg( require( \"../../www/images/cards/backing/GreenCardBase.png\" ) )\nconst metal = getImg( require( \"../../www/images/cards/backing/metal.png\" ) )\nconst purple = getImg( require( \"../../www/images/cards/backing/purple.png\" ) )\n\n//ANIMATION RENDER Access\nconst hill = getImg( require( \"../../www/images/tiles/flat/hill5.png\" ) )\nconst grass = getImg( require( \"../../www/images/tiles/flat/grass.png\" ) )\n\nexport type CardType = {\n    name: string\n    getDescription: ( card: Card ) => string\n    color: string\n    sprite: HTMLImageElement\n    backing: HTMLImageElement\n    canApplyToEmptyTiles: boolean\n    getTilesInRange: ( card: Card, user: Unit ) => Vector[]\n\n    onApplyToTile?: ( card: Card, user: Unit, pos: Vector, target?: Unit ) => void\n    getTilesEffected?: ( user: Unit, pos: Vector ) => Vector[]\n\n    render?: ( animationFrame: number, user: Unit, pos: Vector ) => void\n    renderFrames?: number,\n\n    damage: number,\n    dim?: Vector,\n    range: number,\n    minDist: number,\n    friendly: boolean,\n    exhaustive?: true\n\n    [ index: string ]: any\n}\n\nconst CardTypes: { [ name: string ]: CardType } = {\n    //------------------------------------------------------- CHROME -------------------------------------------------\n    laser: {\n        name: \"Laser\",\n        getDescription: card => `Deal ${ card.type.damage } damage, Take 1 damage`,\n        color: \"#969696\",\n        sprite: laser,\n        backing: metal,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => rookStyleTargets( user.pos, { range: card.type.range } ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            target?.addHealth( -card.type.damage )\n            user.addHealth( -1 )\n\n        },\n\n        render: ( animationFrame, user, pos ) => {\n            let g = Graphics.instance\n            let game = Game.instance\n            let match = game.match\n            let tileSize = 32\n            let target = match.getUnit( pos )\n            if ( target ) {\n                let userPos = user.pos.scale( tileSize ).add( new Vector( tileSize / 2, tileSize / 2 ) )\n                let targetPos = target.pos.scale( tileSize ).add( new Vector( tileSize / 2, tileSize / 2 ) )\n\n                g.c.strokeStyle = \"rgba(255, 0, 0, 1)\"\n                g.c.lineWidth = Math.cos( animationFrame ) * 20\n                g.c.beginPath()\n                g.c.moveTo( userPos.x, userPos.y )\n                g.c.lineTo( targetPos?.x, targetPos?.y )\n                g.c.stroke()\n                // console.log(\"using animation\")\n            }\n        },\n        renderFrames: 10,\n\n        cost: 1,\n        damage: 6,\n        range: 8,\n        minDist: 2,\n        friendly: false\n    },\n    energyArmor: {\n        name: \"Energy Armor\",\n        getDescription: card => `Block ${ card.type.damage } damage while in hand, -Draw 1 card, -Exhaustive`,\n        color: \"#6BB5FF\",\n        sprite: energyArmor,\n        backing: metal,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            user.drawCard( 1 )\n        },\n\n        cost: 0,\n        damage: 2,\n        range: 0,\n        minDist: 0,\n        friendly: true,\n        exhaustive: true\n    },\n    shieldCharge: {\n        name: \"Shield Charge\",\n        getDescription: card => `Generate ${ card.type.damage } Energy Armor`,\n        color: \"#6BB5FF\",\n        sprite: shieldCharge,\n        backing: metal,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            user.gainCard( CardTypes.energyArmor, card.type.damage )\n        },\n\n        cost: 1,\n        damage: 2,\n        range: 0,\n        minDist: 0,\n        friendly: true\n    },\n    coreCharge: {\n        name: \"Core Charge\",\n        getDescription: card => `Gain ${ card.type.count } Fuel Card`,\n        color: \"#6BB5FF\",\n        sprite: shieldCharge,\n        backing: metal,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            user.draw.add( CardTypes.fuel, card.type.count )\n            // user.gainCard( CardTypes.fuel, card.type.count )\n        },\n\n        cost: 1,\n        damage: 0,\n        range: 0,\n        minDist: 0,\n        friendly: true,\n        count: 1\n    },\n    energyFist: {\n        name: \"Energy Fist\",\n        getDescription: card => `Deal ${card.type.damage} damage, knockback target ${card.type.minDist} tiles`,\n        color: \"#6BB5FF\",\n        sprite: energyFist,\n        backing: metal,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => rookStyleTargets( user.pos, { range: card.type.range }),\n        onApplyToTile: ( card, user, pos, target ) => {\n            let match = Game.instance.match\n            target?.addHealth(-card.type.damage)\n            //use targetalongline\n            if (target) {\n                let backboard = targetsAlongLine(\n                    target.pos,\n                    pos.subtract(user.pos).unit(),\n                    { range: card.type.minDist, ignoreObstacles: false }\n                )\n                let lastTile = backboard.pop()\n                if (lastTile && match.map.contains(lastTile)) {\n                    target.pos = lastTile\n                }\n            }\n        },\n\n        cost: 1,\n        damage: 6,\n        range: 1,\n        minDist: 3,\n        friendly: false\n    },\n    barrier: {\n        name: \"Phase Shift\",\n        getDescription: card => `Move ${card.type.range} in any direction, Ignores obstacles`,\n        color: \"#6BB5FF\",\n        sprite: barrier,\n        backing: metal,\n        canApplyToEmptyTiles: true,\n        getTilesInRange: ( card, user ) => rookStyleTargets( user.pos, { range: card.type.range, ignoreObstacles: true }),\n        onApplyToTile(card, user, pos, target?) {\n            user.pos = pos\n        },\n\n        cost: 0,\n        damage: 0,\n        range: 1,\n        minDist: 1,\n        friendly: false,\n        mobile: true\n    },\n    //------------------------------------------------------- EARTH -----------------------------------------------------\n    bouldertoss: {\n        name: \"Boulder Toss\",\n        getDescription: card => `Deal ${ card.type.damage } damage, -Creates Mountain`,\n        color: \"#b87420\",\n        sprite: boulder,\n        backing: brown,\n        canApplyToEmptyTiles: true,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            // console.log(pos)\n            let match = Game.instance.match\n            match.map.set( pos, Tiles.GrassHill )\n            target?.addHealth( -card.type.damage )\n        },\n\n        render: ( animationFrame, user, pos ) => {\n            // animationFrame = 2 * Math.sin(animationFrame * Math.PI / 2) - 1;\n            let g = Graphics.instance\n            let game = Game.instance\n            let match = game.match\n            let tileSize = 32\n            let halfTile = new Vector( tileSize / 2, tileSize / 2 )\n\n            //THE BIG LIE\n            //rendering an empty tile even though its actually already a mountain\n            let endTile = pos.scale( tileSize )\n            g.drawSheetFrame( grass, 32, endTile.x, endTile.y, 0 )\n            let heightBump = new Vector( 0, -20 )\n            let midPos = user.pos.lerp( pos, animationFrame ).scale( tileSize ).add( heightBump )\n            let yCurve = new Vector( 0, -Math.sin( animationFrame * Math.PI ) * 20 )\n            for ( let i = 0; i < 5; i++ ) {\n                let noiseVector = new Vector( Math.sin( i ) * 8, Math.cos( i ) * 8 )\n                let spot = midPos.add( noiseVector ).add( yCurve ).add( halfTile )\n                g.fillCircle( spot, 10, `rgba(${ i * 15 }, 0, 0, 1)` )\n            }\n        },\n        renderFrames: 25,\n\n        cost: 1,\n        damage: 3,\n        range: 5,\n        minDist: 2,\n\n        friendly: false,\n\n    },\n    plateShift: {\n        name: \"Plate Shift\",\n        getDescription: card => `Drop ${ card.type.dim!.x }x${ card.type.dim!.y } Mountains`,\n        color: \"#b87420\",\n        sprite: gorge,\n        backing: brown,\n        canApplyToEmptyTiles: true,\n        getTilesInRange: ( card, user ) => rookStyleTargets( user.pos, { range: card.type.range }),\n        onApplyToTile: ( card, user, pos, target ) => {\n            let match = Game.instance.match\n            match.map.set( pos, Tiles.GrassHill )\n        },\n        getTilesEffected( user, pos ) {\n            let match = Game.instance.match\n            let tilesEffected: Vector[] = [ pos ]\n            let dim = this.dim!\n            //get relative direction from user\n            for ( let x = 0; x < dim.x; x++ ) {\n                for ( let y = 0; y < dim.y; y++ ) {\n                    let tile = pos.add( new Vector( x - 1, y - 1 ) )\n                    if ( !tile.equals( pos ) ) {\n                        tilesEffected.push( tile )\n                    }\n                }\n            }\n            return tilesEffected\n        },\n\n        cost: 1,\n        damage: 0,\n        dim: new Vector( 3, 3 ),\n        range: 3,\n        minDist: 3,\n        friendly: false,\n\n    },\n    mine: {\n        name: \"Mine\",\n        getDescription: card => `Deal ${ card.type.damage } damage, Gain 1 FUEL, -Clears Mountains`,\n        color: \"#b87420\",\n        sprite: mine,\n        backing: brown,\n        canApplyToEmptyTiles: true,\n        getTilesInRange: ( card, user ) => rookStyleTargets(\n            user.pos, { range: card.type.range, ignoreObstacles: true, ignoreElevation: true }\n        ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            // console.log(pos)\n            let match = Game.instance.match\n            // console.log(match.map.get(pos))\n            if ( match.map.get( pos ) == Tiles.GrassHill ) {\n                match.map.set( pos, Tiles.Grass )\n                // for ( let i = 0; i < 1; i++ ) {\n                let card = new Card()\n                card.type = CardTypes.fuel\n                user.draw.cards.push( card )\n                // }\n            }\n            target?.addHealth( -card.type.damage )\n\n        },\n\n        cost: 1,\n        damage: 6,\n        range: 1,\n        minDist: 1,\n        friendly: false,\n\n    },\n    fuel: {\n        name: \"Fuel\",\n        getDescription: card => `Gain ${ card.type.damage } energy, -Exhaustive`,\n        color: \"#aaaaaa\",\n        sprite: ore,\n        backing: brown,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            //Exhaustive\n            //look for the card in the users Discard Pile and remove it\n            target?.addEnergy( card.type.damage )\n            user?.addEnergy( -card.type.cost )\n            user.discard.cards.pop()\n        },\n\n        cost: 0,\n        damage: 1,\n        range: 1,\n        minDist: 0,\n        friendly: true,\n        exhaustive: true\n    },\n    gorge: {\n        name: \"Gorge\",\n        getDescription: card => `Charge through a line of Mountains, Deal ${card.type.damage} damage`,\n        color: \"#b87420\",\n        sprite: blastCharge,\n        backing: brown,\n        canApplyToEmptyTiles: true,\n        getTilesInRange: ( card, user ) => rookStyleTargets( user.pos, {\n            range: card.type.range,\n            ignoreObstacles: false,\n            ignoreElevation: false,\n            passable: ( match, pos ) =>  {\n                let elevation = match.map.getElevation( pos )\n                // console.log(elevation)\n                return !(elevation < 0)\n            }\n        } ),\n        getTilesEffected( user, pos ) {\n            let match = Game.instance.match\n            let tilesEffected: Vector[] = [ pos ]\n            let dim = this.dim!\n            //get relative direction from user\n            let direction = user.pos.subtract( pos )\n            for ( let i = 0; i < direction.length; i++ ) {\n                let step = direction.unit()\n                let tile = user.pos.subtract( step.scale( i ) )\n                tile = new Vector( Math.round( tile.x ), Math.round( tile.y ) )\n                if ( !tile.equals( user.pos ) && match.map.contains( tile ) ) {\n                    tilesEffected.push( tile )\n                }\n            }\n            return tilesEffected\n        },\n        onApplyToTile: ( card, user, pos, target ) => {\n            // console.log(pos)\n            let match = Game.instance.match\n            // console.log(match.map.get(pos))\n            if ( match.map.get( pos ) == Tiles.GrassHill ) {\n                match.map.set( pos, Tiles.Grass )\n            }\n            if ( target ) {\n                if ( target !== user ) {\n                    target?.addHealth( -card.type.damage )\n                }\n            }\n            user.pos = pos\n        },\n        cost: 1,\n        damage: 3,\n        range: 5,\n        minDist: 1,\n        friendly: false\n    },\n    dynamite: {\n        name: \"Dynamite\",\n        getDescription: card => `Deal ${card.type.damage} damage, in a ${card.type.dim?.x}x${card.type.dim?.y} area -Clears Mountains`,\n        color: \"#b87420\",\n        sprite: dynamite,\n        backing: brown,\n        canApplyToEmptyTiles: true,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            let match = Game.instance.match\n            if (match.map.getElevation(pos) == 1) {\n                match.map.set( pos, Tiles.Grass )\n            }\n            if ( target ) {\n                target?.addHealth( -card.type.damage )\n            }\n        },\n        getTilesEffected( user, pos ) {\n            let match = Game.instance.match\n            let tilesEffected: Vector[] = [ pos ]\n            let dim = this.dim!\n            //get relative direction from user\n            for ( let x = 0; x < dim.x; x++ ) {\n                for ( let y = 0; y < dim.y; y++ ) {\n                    let tile = pos.add( new Vector( x - 1, y - 1 ) )\n                    if ( !tile.equals( pos ) ) {\n                        tilesEffected.push( tile )\n                    }\n                }\n            }\n            return tilesEffected\n        },\n\n        cost: 1,\n        damage: 3,\n        dim: new Vector( 3, 3 ),\n        range: 5,\n        minDist: 2,\n        friendly: false\n    },\n\n    plating: {\n        name: \"Plating\",\n        getDescription: card => `Reduce inbound damage by ${card.type.damage}`,\n        color: \"#b87420\",\n        sprite: plating,\n        backing: brown,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n\n        damage: 1,\n        range: 0,\n        minDist: 1,\n        friendly: false\n    },\n    exhaustPorts: {\n        name: \"Exhaust Ports\",\n        getDescription: card => `draw ${card.type.drawCount}`,\n        color: \"#b87420\",\n        sprite: plating,\n        backing: brown,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile(card, user, pos, target?) {\n            user.drawCard(card.type.drawCount)\n        },\n        healthCost: 2,\n        \n        drawCount: 2,\n        \n        damage: 1,\n        range: 0,\n        minDist: 0,\n        friendly: false\n    },\n\n    //------------------------------------------------------- FLESH ---------------------------------------------\n    claw: {\n        name: \"Claw\",\n        getDescription: card => `Deal ${ card.type.damage } damage, -Exhaustive`,\n        color: \"#af0000\",\n        sprite: claw,\n        backing: flesh,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n\n            if ( target ) {\n                // let bonusDMG = user.maxHealth - user.health\n                // card.type.damage = bonusDMG + 1\n                target.addHealth( -card.type.damage )\n            }\n        },\n\n        cost: 0,\n        damage: 3,\n        range: 1,\n        minDist: 1,\n        friendly: false,\n        exhaustive: true\n    },\n    frenzy: {\n        name: \"Frenzy\",\n        getDescription: card => `-Generate ${card.type.damage} Claw, -Draw ${card.type.drawCount} cards`,\n        color: \"#af0000\",\n        sprite: frendzi,\n        backing: flesh,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            for ( let i = 0; i < card.type.damage; i++ ) {\n                let card = new Card()\n                card.type = CardTypes.claw\n                user.draw.insertAtRandom( card )\n            }\n            user.drawCard(2)\n        },\n\n        cost: 1,\n        drawCount: 2,\n\n        damage: 2,\n        range: 0,\n        minDist: 0,\n        friendly: true\n\n    },\n    leap: {\n        name: \"Leap\",\n        getDescription: card => `Leap to a tile within range, -Ignore Obstacles`,\n        color: \"#af0000\",\n        sprite: leap,\n        backing: flesh,\n        canApplyToEmptyTiles: true,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            if (Game.instance.match.map.contains(pos)) {\n                user.pos = pos\n            }\n        },\n\n        cost: 1,\n        damage: 0,\n        range: 7,\n        minDist: 5,\n        friendly: false\n\n    },\n    lump: {\n        name: \"Lump\",\n        getDescription: card => `Gain ${card.type.damage} HP,     Draw ${card.type.drawCount} Card, -Exhaustive`,\n        color: \"#af0000\",\n        sprite: lump,\n        backing: flesh,\n        canApplyToEmptyTiles: true,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            user.addHealth( card.type.damage )\n            user.drawCard( card.type.drawCount )\n        },\n\n        cost: 0,\n        damage: 4,\n        maxHp: 5,\n        energy: 1,\n        drawCount: 1,\n\n        range: 0,\n        minDist: 0,\n        friendly: false,\n        exhaustive: true\n    },\n    sentience: {\n        name: \"Sentience\",\n        getDescription: card => `Draw ${card.type.drawCount} Cards`,\n        color: \"#af0000\",\n        sprite: bloodClot,\n        backing: flesh,\n        canApplyToEmptyTiles: true,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            user.drawCard( card.type.drawCount )\n        },\n        healthCost: 3,\n\n        damage: 4,\n        drawCount: 3,\n\n        range: 0,\n        minDist: 0,\n        friendly: false\n    },\n    chomp: {\n        name: \"Chomp\",\n        getDescription: card => `Deal ${card.type.damage} damage,\n         -Gain ${card.type.maxHp} MaxHP`,\n        color: \"#af0000\",\n        sprite: chomp,\n        backing: flesh,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => rookStyleTargets( user.pos, { range: card.type.range } ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            if ( target ) {\n                // for ( let i = 0; i < card.type.drawCount; i++ ) {\n                //     let card = new Card()\n                //     card.type = CardTypes.lump\n                //     user.draw.cards.push( card )\n                // }\n                user.addMaxHealth( card.type.maxHp )\n\n                target.addHealth( -card.type.damage )\n            }\n        },\n\n        cost: 1,\n        damage: 4,\n        drawCount: 1,\n        maxHp: 1,\n\n        range: 2,\n        minDist: 0,\n        friendly: false\n\n    },\n    acid: {\n        name: \"Acid Spit\",\n        getDescription: card => `Discard a random card, Deal ${card.type.damage} damage`,\n        color: \"#af0000\",\n        sprite: acid,\n        backing: flesh,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            \n            if (user.hand.length > 0) {\n                let random = randomFloor(user.hand.length)\n                user.discardCardAt(random)\n            }\n            if ( target ) {\n                target.addHealth( -card.type.damage)\n            }\n        },\n\n        cost: 1,\n        damage: 5,\n        range: 5,\n        minDist: 2,\n        friendly: false\n    },\n    bloodClot: {\n        name: \"Blood Clot\",\n        getDescription: card => `Heal ${card.type.heal} HP`,\n        color: \"#af0000\",\n        sprite: bloodClot,\n        backing: flesh,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile(card, user, pos, target?) {\n            // user.addSpeed( -card.type.speed )\n            user.addHealth( card.type.heal )\n        },\n\n        cost: 0,\n        heal: 2,\n\n        damage: 0,\n        range: 0,\n        minDist: 0,\n        friendly: false\n    },\n\n    //------------------------------------------------------- UNIVERSAL ---------------------------------------\n    repair: {\n        name: \"Repair-Kit\",\n        getDescription: card => `Heal unit for ${ card.type.damage } health`,\n        color: \"#32a852\",\n        sprite: repair,\n        backing: metal,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            target?.addHealth( card.type.damage )\n\n            //Exhaustive\n            //look for the card in the users Discard Pile and remove it\n            user.discard.cards.pop()\n        },\n        render: ( animationFrame, user, pos ) => {\n            let g = Graphics.instance\n            let game = Game.instance\n            let match = game.match\n            let tileSize = 32\n            let target = match.getUnit( pos )\n            if ( target ) {\n                let targetPos = target.pos.scale( tileSize ).add( new Vector( tileSize / 2, tileSize / 2 ) )\n                let color = `rgba(0, 255, 0, ${ animationFrame })`\n                // g.drawRect(targetPos, new Vector(tileSize, tileSize).scale(2), color)\n                g.fillCircle( targetPos, Math.abs( Math.sin( animationFrame * Math.PI * 6 ) * tileSize * 0.8 ), color )\n                console.log( \"drawing repair!\" )\n            }\n        },\n        renderFrames: 40,\n\n        cost: 0,\n        damage: 7,\n        range: 1,\n        minDist: 0,\n        friendly: true,\n        exhaustive: true\n\n\n    },\n    sprint: {\n        name: \"Sprint\",\n        getDescription: card => `Take ${ card.type.damage } damage,\n         Gain ${ card.type.range } speed,\n         Gain ${ card.type.cost } Energy`,\n        color: \"#667799\",\n        sprite: sprint,\n        backing: metal,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            if ( target ) {\n                user.addHealth( -card.type.damage )\n                target.addEnergy( card.type.cost )\n                target.addSpeed( card.type.range )\n            }\n            console.log( user.discard.cards.pop() )\n        },\n\n        cost: 1,\n        damage: 3,\n        range: 1,\n        minDist: 0,\n        friendly: true,\n        exhaustive: true\n\n    },\n    rifle: {\n        name: \"Rifle\",\n        getDescription: card => `Deal ${ card.type.damage } damage to target`,\n        color: \"#969696\",\n        sprite: rifle,\n        backing: metal,\n        canApplyToEmptyTiles: false,\n        // getTilesInRange: ( card, user ) => lineOfSightTargets( user.pos, { range: card.type.range } ),\n        getTilesInRange: ( card, user ) => rookStyleTargets( user.pos, { range: card.type.range } ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            target?.addHealth( -card.type.damage )\n            //this card should target using LOS(Line of Sight)\n        },\n\n        render: ( animationFrame, user, pos ) => {\n            let g = Graphics.instance\n            let game = Game.instance\n            let world = game.match\n            let tileSize = 32\n            let target = world.getUnit( pos )\n            if ( target ) {\n                let userPos = user.pos.scale( tileSize ).add( new Vector( tileSize / 2, tileSize / 2 ) )\n                let targetPos = target.pos.scale( tileSize ).add( new Vector( tileSize / 2, tileSize / 2 ) )\n                let bullet = {\n                    pos: userPos.lerp( targetPos, animationFrame ),\n                    radius: 2,\n                    color: \"rgba(50, 0, 0)\"\n                }\n                for ( let i = 0; i < 5; i++ ) {\n                    let spread = 4\n                    let noise = new Vector( Math.random() * spread, Math.random() * spread )\n                    g.fillCircle( bullet.pos.add( noise ), bullet.radius, bullet.color )\n                }\n            }\n        },\n        renderFrames: 4,\n\n        cost: 1,\n        damage: 4,\n        range: 3,\n        minDist: 2,\n\n        friendly: false\n    },\n    grapplingHook: {\n        name: \"Grappling Hook\",\n        getDescription: card => `Pull you to target from ${ card.type.range } tiles away.`,\n        color: \"#969696\",\n        sprite: grapplingHook,\n        backing: metal,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            if ( target ) {\n                let xShift = ( target.pos.x < user.pos.x ) ?\n                    target.pos.x + 1 : ( target.pos.x == user.pos.x ) ?\n                        target.pos.x : target.pos.x - 1\n                let yShift = ( target.pos.y < user.pos.y ) ?\n                    target.pos.y + 1 : ( target.pos.y == user.pos.y ) ?\n                        target.pos.y : target.pos.y - 1\n                let newPos = new Vector( xShift, yShift )\n                let path = [ user.pos, newPos ]\n                user.move( path )\n            }\n\n        },\n\n        cost: 1,\n        damage: 0,\n        range: 8,\n        minDist: 1,\n        friendly: false\n\n    },\n    //------------------------------------------------------- TREE ----------------------------------------------\n    perfume: {\n        name: \"Perfume\",\n        getDescription: card => `Reduce MaxHP by ${ card.type.damage }, increase Speed by ${ card.type.damage }`,\n        color: \"#026822\",\n        sprite: pollen,\n        backing: green,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n\n            if ( target ) {\n                target.speed += card.type.damage\n                target.addMaxHealth( -card.type.damage )\n            }\n        },\n\n        cost: 1,\n        damage: 2,\n        range: 6,\n        minDist: 0,\n        friendly: false\n    },\n    root: {\n        name: \"Root\",\n        getDescription: card => `Immobilize Target Target Heals ${ card.type.damage } HP`,\n        color: \"#026822\",\n        sprite: root,\n        backing: green,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n\n            if ( target ) {\n                target.speed = 1\n                target.addHealth( card.type.damage )\n            }\n        },\n\n        cost: 1,\n        damage: 8,\n        range: 6,\n        minDist: 0,\n        friendly: false\n    },\n    fungus: {\n        name: \"Fungus\",\n        getDescription: card => `Target Gains ${card.type.energy} Energy`,\n        color: \"#026822\",\n        sprite: fungus,\n        backing: green,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            if ( target ) {\n                target.addEnergy(card.type.energy)\n            }\n        },\n\n        speedCost: 2,\n        energy: 1,\n        damage: 8,\n        range: 4,\n        minDist: 0,\n        friendly: false\n    },\n    flower: {\n        name: \"Flower\",\n        getDescription: card => `Grant Target ${ card.type.damage } Fruits`,\n        color: \"#026822\",\n        sprite: flower,\n        backing: green,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            if ( target ) {\n                target.draw.add( CardTypes.fruit, 2 )\n            }\n        },\n        cost: 1,\n        damage: 2,\n        range: 4,\n        minDist: 0,\n        friendly: false\n    },\n    fruit: {\n        name: \"Fruit\",\n        getDescription: card => `Grant User ${ card.type.damage } HP -Exhaustive`,\n        color: \"#026822\",\n        sprite: fruit,\n        backing: green,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            target?.addHealth( card.type.damage )\n        },\n\n        cost: 0,\n        damage: 2,\n        range: 1,\n        minDist: 0,\n        friendly: true,\n        exhaustive: true,\n    },\n    bark: {\n        name: \"Bark\",\n        getDescription: card => `Heal a target for ${ card.type.heal } HP`,\n        color: \"#026822\",\n        sprite: bark,\n        backing: green,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile(card, user, pos, target?) {\n            target?.addHealth(card.type.heal)\n        },\n\n        speedCost: 2,\n        damage: 0,\n        heal: 3,\n        range: 2,\n        minDist: 0,\n        friendly: false\n    },\n    boomShroom: {\n        name: \"BoomShroom\",\n        getDescription: card => `Reduce MaxHP: ${card.type.damage} in a ${card.type.dim?.x}x${card.type.dim?.y} area -Clears Mountains`,\n        color: \"#026822\",\n        sprite: boomShroom,\n        backing: green,\n        canApplyToEmptyTiles: true,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            let match = Game.instance.match\n            if (match.map.getElevation(pos) == 1) {\n                match.map.set( pos, Tiles.Grass )\n            }\n            if ( target ) {\n                target?.addMaxHealth( -card.type.damage )\n            }\n        },\n        getTilesEffected( user, pos ) {\n            let match = Game.instance.match\n            let tilesEffected: Vector[] = [ pos ]\n            let dim = this.dim!\n            //get relative direction from user\n            for ( let x = 0; x < dim.x; x++ ) {\n                for ( let y = 0; y < dim.y; y++ ) {\n                    let tile = pos.add( new Vector( x - 1, y - 1 ) )\n                    if ( !tile.equals( pos ) ) {\n                        tilesEffected.push( tile )\n                    }\n                }\n            }\n            return tilesEffected\n        },\n\n        cost: 1,\n        damage: 3,\n        dim: new Vector( 3, 3 ),\n        range: 5,\n        minDist: 2,\n        friendly: false\n    },\n    //----------------------------------------------- ELDRITCH --------------------------------------------\n    tentacle: {\n        name: \"Tentacle Pull\",\n        getDescription: card => `Pull target to you from ${ card.type.range } tiles away.`,\n        color: \"#990099\",\n        sprite: tentacle,\n        backing: purple,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            // console.log(user.hand)\n            if ( target ) {\n                //Chaining Ternary functions are weird man\n                let xShift = ( user.pos.x < target.pos.x ) ?\n                    user.pos.x + 1 : ( user.pos.x == target.pos.x ) ?\n                        user.pos.x : user.pos.x - 1\n                let yShift = ( user.pos.y < target.pos.y ) ?\n                    user.pos.y + 1 : ( user.pos.y == target.pos.y ) ?\n                        user.pos.y : user.pos.y - 1\n                let newPos = new Vector( xShift, yShift )\n                let path = [ target.pos, newPos ]\n                target.move( path )\n            }\n\n        },\n\n        cost: 1,\n        damage: 0,\n        range: 6,\n        minDist: 1,\n        friendly: false\n\n    },\n    bubbletoss: {\n        name: \"Bubble Toss\",\n        getDescription: card => `Create shallow water, Deal ${ card.type.damage } damage`,\n        color: \"#990099\",\n        sprite: jelly,\n        backing: purple,\n        canApplyToEmptyTiles: true,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n            let match = Game.instance.match\n            match.map.set( pos, Tiles.WaterShallow )\n            target?.addHealth( -card.type.damage )\n\n        },\n\n        cost: 1,\n        damage: 2,\n        range: 5,\n        minDist: 2,\n        friendly: false\n\n    },\n    warp: {\n        name: \"Wrong Warp\",\n        getDescription: card => `Swap places with target, Gain ${card.type.damage} Wrong Warp`,\n        color: \"#990099\",\n        sprite: warp,\n        backing: purple,\n        canApplyToEmptyTiles: false,\n        getTilesInRange: ( card, user ) => targetsWithinRange( user.pos, card.type.minDist, card.type.range ),\n        onApplyToTile: ( card, user, pos, target ) => {\n\n            if (target) {\n                let store = target.pos\n                target.pos = user.pos\n                user.pos = store\n                user.discard.add(card.type, card.type.damage)\n            }\n        },\n\n        cost: 1,\n        damage: 1,\n        range: 6,\n        minDist: 2,\n        friendly: false\n    },  \n}\n\nexport default CardTypes\n\nconst cardTypeList = Object.values( CardTypes )\nexport function randomCardType() {\n    let i = Math.floor( Math.random() * cardTypeList.length )\n    return cardTypeList[ i ]\n}\n\ntype scanOptions = {\n    range?: number,\n    ignoreObstacles?: boolean,\n    ignoreElevation?: boolean,\n    result?: Vector[],\n    passable?: ( match: Match, pos: Vector ) => boolean\n}\n\n// Target generation\nfunction targetsAlongLine(\n    pos: Vector, delta: Vector,\n    {\n        range = Infinity,\n        ignoreObstacles = false,\n        ignoreElevation = false,\n        result = [],\n        passable = undefined\n    }: scanOptions\n) {\n    let match = Game.instance.match\n    let elevation0 = match.map.getElevation( pos )\n\n    if ( passable == undefined )\n        passable = ( match, pos ) => ignoreObstacles || match.isWalkable( pos, false )\n\n    for ( let i = 1; i <= range; i++ ) {\n        let p2 = pos.add( delta.scale( i ) )\n        let inBounds = match.map.contains( p2 )\n        let hitsUnit = match.getUnit( p2 ) !== undefined\n\n        //Manually step through and assign tiles\n        //steal code from blastCharges getTilesEffected\n\n        if ( !inBounds || !passable( match, p2 ) )\n            break\n\n        let contained = false\n        result.forEach( ( val, i ) => {\n            if ( p2.equals( val ) ) {\n                contained = true\n            }\n        } )\n        if ( !contained ) {\n            result.push( p2 )\n        }\n    }\n    return result\n}\n\nfunction rookStyleTargets(\n    pos: Vector,\n    {\n        range = Infinity, ignoreObstacles = false, ignoreElevation = false, result = [],\n        passable = undefined\n    }: scanOptions\n) {\n    targetsAlongLine( pos, new Vector( 1, 0 ), { range, ignoreObstacles, result, passable } )\n    targetsAlongLine( pos, new Vector( -1, 0 ), { range, ignoreObstacles, result, passable } )\n    targetsAlongLine( pos, new Vector( 0, 1 ), { range, ignoreObstacles, result, passable } )\n    targetsAlongLine( pos, new Vector( 0, -1 ), { range, ignoreObstacles, result, passable } )\n    return result\n}\n\nfunction bishopStyleTargets(\n    pos: Vector,\n    {\n        range = Infinity, ignoreObstacles = false, ignoreElevation = false, result = [],\n        passable = undefined\n    }: scanOptions\n) {\n    targetsAlongLine( pos, new Vector( 1, 1 ), { range, ignoreObstacles, result } )\n    targetsAlongLine( pos, new Vector( -1, -1 ), { range, ignoreObstacles, result } )\n    targetsAlongLine( pos, new Vector( -1, 1 ), { range, ignoreObstacles, result } )\n    targetsAlongLine( pos, new Vector( 1, -1 ), { range, ignoreObstacles, result } )\n    return result\n}\n\nfunction lineOfSightTargets(\n    pos: Vector,\n    {\n        range = Infinity, ignoreObstacles = false, ignoreElevation = false, result = [],\n        passable = undefined\n    }: scanOptions\n) {\n    let map = Game.instance.match.map\n    for ( let x = 0; x <= map.width; x++ ) {\n        for ( let y = 0; y <= map.height; y++ ) {\n            let tile = new Vector( x, y )\n            let direction = tile.subtract( pos )\n            direction = direction.scale( 1 / direction.length )\n            targetsAlongLine( pos, direction, { range: range, ignoreObstacles: false, result } )\n        }\n    }\n    return result\n}\n\nexport function targetsWithinRange( pos: Vector, minDist: number, maxDist: number, result: Vector[] = [] ) {\n    // console.log(\"target start:\", pos)\n    for ( let dx = -maxDist; dx <= maxDist; dx++ ) {\n        for ( let dy = -maxDist; dy <= maxDist; dy++ ) {\n            let r = Math.abs( dx ) + Math.abs( dy )\n            if ( r >= minDist && r <= maxDist )\n                result.push( pos.addXY( dx, dy ) )\n        }\n    }\n    return result\n}\n","// import Game from \"../Game\"\n// import Graphics from \"../Graphics\"\n// import { Vector } from \"../math/Vector\"\n// import Unit from \"./Unit\"\n// import { getImg, randomColor } from \"../common/utils\"\n// import Match from \"./Match\"\n// import CardTypes, { CardType, randomCardType } from \"../CardTypes\"\n\nimport { dirxml } from \"console\"\nimport Graphics from \"../../common/Graphics\"\nimport { randomColor } from \"../../common/utils\"\nimport Game from \"../../Game\"\nimport { Vector } from \"../../math/Vector\"\nimport Unit from \"../mech/Unit\"\nimport CardTypes, { randomCardType } from \"./CardTypes\"\n\n//this requires two periods while Cardtypes require only one period, idk why...\n// const backing = getImg( require( \"../www/images/cards/RedCardBase.png\" ) )\n\nexport default class Card {\n    static dimensions = new Vector( 48, 64 )\n\n    yRotation: number = 0\n    pos: Vector = new Vector( 0, 0 )\n    color: string = randomColor()\n    type = CardTypes.laser\n\n    constructor( cardType?: typeof CardTypes.laser ) {\n        if ( cardType ) {\n            this.type = cardType\n        } else {\n            this.type = randomCardType()\n        }\n    }\n\n    render() {\n        let g = Graphics.instance\n        let { color, backing, sprite, name } = this.type\n        \n        let c = Math.cos( -this.yRotation )\n        g.vTranslate( Card.dimensions.scale( 0.5 ) )\n        g.c.scale( c, 1 )\n        g.vTranslate( Card.dimensions.scale( -0.5 ) )\n\n        if ( this.yRotation >= Math.PI / 2 ) {\n            // Back face\n            g.strokeRect( new Vector( 0, 0 ), Card.dimensions, \"#ffddff\" )\n            g.drawRect( new Vector( 0, 0 ), Card.dimensions, color )\n        } else {\n            // Front face\n            g.c.drawImage( backing, 0, 0, Card.dimensions.x, Card.dimensions.y, 0, 0, Card.dimensions.x, Card.dimensions.y )\n            //graphic\n            g.c.drawImage( sprite, 0, 0, Card.dimensions.x, Card.dimensions.y, 7, 7, Card.dimensions.x * 0.75, Card.dimensions.y * 0.75 )\n            //background boxing\n            g.drawRect(new Vector(0, 0), new Vector(Card.dimensions.x, 8), color)\n            //title\n            g.setFont( 5, \"pixel2\" )\n            g.drawText( new Vector( 3, 1 ), name, \"#f0ead8\" )\n            \n            //Cost Display\n            let cost = {\n                dim: new Vector(10, 10),\n                pos: new Vector(0, 7),\n                green: {\n                    dark: \"rgb(30, 125, 30)\",\n                    light: \"rgb(0, 240, 0)\"\n                },\n                red: {\n                    light: \"rgb(255, 0, 0)\",\n                    // dark: \"rgb(75, 0, 0)\",\n                    dark: \"rgb(100, 0, 0)\",\n                },\n                blue: {\n                    light: \"rgb(100, 100, 255)\",\n                    // dark: \"rgb(75, 0, 0)\",\n                    dark: \"rgb(0, 0, 75)\",\n                },\n                index: 0\n            }\n            let isCostDefined = this.type.cost || this.type.healthCost || this.type.speedCost\n            if ( isCostDefined ) {\n                //branching down backing\n                g.drawRect(cost.pos, cost.dim, this.type.color)\n            }\n            //Energy Cost Display\n            if (this.type.cost !== undefined) {\n                //energy display\n                g.costDisplay(cost.pos, this.type.cost, cost.green.light, cost.green.dark, Card.dimensions.x/6)\n                cost.index += 1\n            }\n            //Health Cost Display\n            if (this.type.healthCost !== undefined) {\n                //health display\n                let offset = new Vector(cost.dim.x, 0)\n                let pos = cost.index > 0 ? cost.pos.add(offset) : cost.pos\n                g.costDisplay(pos, this.type.healthCost, cost.red.light, cost.red.dark, Card.dimensions.x/6)\n                cost.index += 1\n            }\n            //Speed Cost Display\n            if (this.type.speedCost !== undefined) {\n                //health display\n                let offset = new Vector(0, cost.dim.y)\n                let pos = cost.index > 0 ? cost.pos.add(offset) : cost.pos\n                g.costDisplay(pos, this.type.speedCost, cost.blue.light, cost.blue.dark, Card.dimensions.x/6)\n            }\n            //card description\n            g.drawRect( new Vector( 4, 40 ), new Vector( 40, 20 ), this.type.color )\n            let description = this.type.getDescription( this )\n            let lines = getLines( description, 17 )\n            lines.forEach( ( line, index ) => {\n                g.setFont( 5, \"ariel\" )\n                // g.setFont( 3, \"pixel2\" )\n                g.drawText( new Vector( 6, 42 + index * 4 ), line, \"#f0ead8\" )\n            } )\n        }\n    }\n\n    getTilesInRange( user: Unit ) {\n        return this.type.getTilesInRange( this, user )\n    }\n\n    apply( user: Unit, pos: Vector ) {\n        const type = this.type\n        const dim = type.dim\n        const match = Game.instance.match\n        let target = match.getUnit( pos )\n        if ( type.onApplyToTile ) {\n            if ( type.getTilesEffected ) {\n                type.getTilesEffected( user, pos ).forEach( ( tile, i ) => {\n                    target = match.getUnit( tile )\n                    type.onApplyToTile!( this, user, tile, target )\n                } )\n            }\n            type.onApplyToTile( this, user, pos, target )\n        }\n        // console.log(\"Logging CardCost: \", type.cost)\n        if ( type.cost !== undefined) {\n            user.addEnergy( -type.cost )\n        }\n        if ( type.healthCost !== undefined) {\n            user.addHealth( -type.healthCost)\n        }\n        if ( type.speedCost !== undefined) {\n            user.addSpeed( -type.speedCost)\n        }\n    }\n}\n\nexport function getLines( text: string, charsPerLine: number ) {\n    let words = text.split( \" \" )\n    if ( words.length == 0 ) return []\n    let lines: string[] = []\n    let line = words[ 0 ]\n    for ( let i = 1; i < words.length; i++ ) {\n        let word = words[ i ]\n        let nextLine = line + \" \" + word\n        if ( nextLine.length > charsPerLine ) {\n            lines.push( line )\n            line = word\n        } else {\n            line = nextLine\n        }\n    }\n    if ( line.length > 0 )\n        lines.push( line )\n    return lines\n}","import Graphics from \"../../common/Graphics\"\nimport Scene from \"../../common/Scene\"\nimport Game from \"../../Game\"\nimport { lerp } from \"../../math/math\"\nimport Matrix from \"../../math/Matrix\"\nimport { Vector } from \"../../math/Vector\"\nimport Card from \"../card/Card\"\nimport Unit from \"../mech/Unit\"\n\nexport default class CardTray {\n    static selectionTimeout = 500\n    static restingDepth = 24\n    index = -1\n    lastSelectTime: number = -Infinity\n    isPickingTarget = false\n\n    constructor() {\n    }\n\n    hasCardSelected() { return this.index > -1 }\n\n    selectedCard( unit: Unit ) {\n        // console.log(\"selecting a card!:\", Unit)\n        return unit?.hand.cards[ this.index ]\n    }\n\n    selectIndex( index: number ) {\n        this.index = index\n        this.lastSelectTime = Date.now()\n    }\n\n    deselect() {\n        this.selectIndex( -1 )\n        this.isPickingTarget = false\n    }\n\n    onSelectUnit( unit: Unit ) {\n        this.deselect()\n        this.lerpCards( unit, 1 )\n        let { hand, draw, discard } = unit\n        let decks = [ hand, draw, discard ]\n        for ( let deck of decks ) {\n            for ( let card of deck.cards ) {\n                card.yRotation = Math.PI / 2\n            }\n        }\n    }\n\n    update( unit: Unit ) {\n        let { lastSelectTime } = this\n        let game = Game.instance\n        this.lerpCards( unit, .2 )\n        if ( this.hasCardSelected() && !this.isPickingTarget ) {\n            let now = Date.now()\n            let dt = now - lastSelectTime\n            if ( dt > CardTray.selectionTimeout && game.match.playerTurn() ) {\n                this.selectIndex( -1 )\n            }\n        }\n    }\n\n    lerpCards( unit: Unit, alpha: number ) {\n        let flipRate = 0.5\n        if ( unit ) {\n            let { hand, draw, discard } = unit\n            hand.cards.forEach( ( card, i ) => {\n                let targetPos = this.handPosition( hand.length, i )\n                card.pos = card.pos.lerp( targetPos, alpha )\n                card.yRotation = lerp( card.yRotation, 0, alpha * flipRate )\n            } )\n            draw.cards.forEach( ( card, i ) => {\n                let targetPos = this.drawPosition( draw.length, i )\n                card.pos = card.pos.lerp( targetPos, alpha )\n                card.yRotation = lerp( card.yRotation, Math.PI, alpha * flipRate )\n            } )\n            discard.cards.forEach( ( card, i ) => {\n                let targetPos = this.discardPosition( discard.length, i )\n                card.pos = card.pos.lerp( targetPos, alpha )\n                card.yRotation = lerp( card.yRotation, Math.PI, alpha * flipRate )\n            } )\n        }\n    }\n\n    static handMargin = 3\n    handBase( handLength: number ) {\n        const marigin = CardTray.handMargin\n        let stride = Card.dimensions.x + marigin\n        let width = stride * handLength - marigin\n        let screenSize = Game.instance.screenDimensions()\n        return new Vector( screenSize.x / 2 - width / 2, screenSize.y - Card.dimensions.y + CardTray.restingDepth )\n    }\n    handPosition( handLength: number, cardIndex: number ) {\n        const marigin = CardTray.handMargin\n        let stride = Card.dimensions.x + marigin\n        let elevation = cardIndex == this.index ? CardTray.restingDepth : 0\n        return this.handBase( handLength ).addXY( stride * cardIndex, -elevation )\n    }\n    drawPosition( handLength: number, cardIndex: number ) {\n        let offset = new Vector( 0.5, 0.5 )\n        let screenSize = Game.instance.screenDimensions()\n        let stride = offset.x, width = stride * handLength\n        let drawBase = new Vector( 0, screenSize.y - Card.dimensions.y / 2.5 )\n        return drawBase.addXY( cardIndex * offset.x, cardIndex * offset.y )\n    }\n    discardPosition( handLength: number, cardIndex: number ) {\n        let offset = new Vector( 0.5, 0.5 )\n        let screenSize = Game.instance.screenDimensions()\n        let stride = offset.x, width = stride * handLength\n        let discardBase = new Vector( screenSize.x - Card.dimensions.x - width, screenSize.y - Card.dimensions.y / 2.5 )\n        return discardBase.addXY( cardIndex * offset.x, cardIndex * offset.y )\n    }\n\n    makeSceneNode( unit: Unit ) {\n        let g = Graphics.instance\n        let game = Game.instance\n        let hand = unit.hand\n        let draw = unit.draw\n        let discard = unit.discard\n        if ( !hand || !draw || !discard ) return\n\n        const marigin = CardTray.handMargin\n        let stride = Card.dimensions.x + marigin\n        let width = stride * hand.length - marigin\n        Scene.node( {\n            description: \"card-tray\",\n            localMatrix: Matrix.vTranslation( this.handBase( hand.length ) ),\n            rect: { width, height: Card.dimensions.y },\n        } )\n        hand.cards.forEach( ( card, i ) => Scene.node( {\n            description: \"card-hand\",\n            localMatrix: Matrix.vTranslation( card.pos ),\n            rect: { width: Card.dimensions.x, height: Card.dimensions.y },\n            onRender: () => card.render(),\n            onHover: () => {\n                if ( game.match.playerTurn() && !this.isPickingTarget ) {\n                    this.selectIndex( i )\n                }\n            },\n            onClick: () => {\n                if ( game.match.playerTurn() ) {\n                    let isSelectedCard = this.index == i\n                    if ( this.isPickingTarget && isSelectedCard ) {\n                        this.deselect()\n                    } else {\n                        this.index = i\n                        this.isPickingTarget = true\n                    }\n                }\n            }\n        } ) )\n\n        draw.cards.forEach( ( card, i ) => Scene.node( {\n            description: \"card-draw\",\n            localMatrix: Matrix.vTranslation( card.pos ),\n            rect: { width: Card.dimensions.x, height: Card.dimensions.y },\n            onRender: () => {\n                card.render()\n                if ( i == draw.length - 1 ) {\n                    //this is where we should draw the final count of cards in the drawPile\n\n                    // g.c.save()\n                    // g.c.scale( -1, 1 )\n                    // g.setFont( 25, \"Times\" )\n                    // let pos = new Vector( -Card.dimensions.x / 4 * 3, Card.dimensions.y / 5 )\n                    // g.drawRect( pos.add( new Vector( -7, -7 ) ), new Vector( 38, 38 ), \"grey\" )\n                    // g.drawRect( pos.add( new Vector( -5, -5 ) ), new Vector( 34, 34 ), \"white\" )\n                    // g.drawText( pos, draw.length.toString(), \"black\" )\n                    // g.c.restore()\n                }\n            }\n        } ) )\n        discard.cards.forEach( ( card, i ) => Scene.node( {\n            description: \"card-discard\",\n            localMatrix: Matrix.vTranslation( card.pos ),\n            rect: { width: Card.dimensions.x, height: Card.dimensions.y },\n            onRender: () => {\n                card.render()\n                if ( i == discard.length - 1 ) {\n                    //this is where we need to display total cards in the discard\n\n                    // g.c.save()\n                    // g.c.scale( -1, 1 )\n                    // g.setFont( 25, \"Times\" )\n                    // let pos = new Vector( -Card.dimensions.x / 4 * 3, Card.dimensions.y / 5 )\n                    // g.drawRect( pos.add( new Vector( -7, -7 ) ), new Vector( 38, 38 ), \"grey\" )\n                    // g.drawRect( pos.add( new Vector( -5, -5 ) ), new Vector( 34, 34 ), \"black\" )\n                    // g.drawText( pos, discard.length.toString(), \"white\" )\n                    // g.c.restore()\n                }\n            }\n        } ) )\n    }\n}","import Graphics from \"../../common/Graphics\"\nimport Scene from \"../../common/Scene\"\nimport Game from \"../../Game\"\nimport Match from \"../../stages/Match\"\nimport { randomInt } from \"../../math/math\"\nimport Matrix from \"../../math/Matrix\"\nimport { Vector } from \"../../math/Vector\"\nimport Team from \"../mech/Team\"\nimport Unit from \"../mech/Unit\"\n\nexport default class UnitTray {\n    private index = -1\n    private hasUnitSelected = false\n\n    constructor() {\n\n    }\n\n    makeSceneNode( pos: Vector, team: Team, flip: boolean = false ) {\n        let g = Graphics.instance\n        let units = team.units\n\n\n        Scene.node( {\n            description: \"unit-tray\",\n            localMatrix: Matrix.translation( pos.x, pos.y ),\n            content: () => {\n                let previousHeight = 0\n                units.forEach( ( unit, i ) => {\n                    const dimLength = 32\n                    const dim = new Vector( 32, 32 )\n                    let scale = 1.5\n                    //resets dimensions depending on selected(scaled) unit\n                    let width = i == team.selectedUnitIndex ? dim.x * scale : dimLength\n                    let height = i == team.selectedUnitIndex ? dim.y * scale : dimLength\n                    //offsets the Ypos of units Displayed after selected(Scaled) unit\n                    let yOffset = team.selectedUnitIndex < i && team.selectedUnitIndex !== -1 ? dimLength * ( scale - 1 ) + 1 : 0\n\n                    Scene.node( {\n                        description: unit.name,\n                        localMatrix: Matrix.translation( 0, dimLength * i + yOffset ),\n                        rect: { width, height },\n                        onRender: () => {\n\n                            g.c.save()\n                            if ( flip ) {\n                                // g.c.translate(dim.x, 0)\n                                g.c.scale( -1, 1 )\n                            }\n\n                            //Scales the selected Unit\n                            if ( i == team.selectedUnitIndex ) {\n                                g.c.scale( scale, scale )\n                            }\n\n                            //Colors\n                            const backing1 = \"rgba(100, 100, 100, 1)\"\n                            const nameBacking = \"rgba(150, 150, 150, 0.7)\"\n\n                            //Display backing\n                            g.drawRect( new Vector( 0, 0 ), dim, backing1 )\n                            g.c.lineWidth = 1\n                            g.strokeRect( new Vector( 0, 0 ), dim, \"black\" )\n                            //unit drawn\n                            // if ( i == team.selectedUnitIndex ) {\n                            //     unit.render( true )\n                            // } else {\n                            //     unit.render( false )\n                            // }\n                            unit.render(false)\n\n                            //unit name display\n                            unit.renderName( new Vector( 0, 19.5 ), \"black\", nameBacking )\n\n                            unit.drawStats()\n\n                            g.c.restore()\n                        },\n                        onClick: () => {\n                            if ( Game.instance.match.playerTurn() ) {\n                                team.selectUnit( unit )\n                            }\n                        }\n                    } )\n                } )\n            }\n        } )\n    }\n}","//import path from \"path/posix\"\nimport { targetsWithinRange } from \"../card/CardTypes\"\nimport Game from \"../../Game\"\n// import Card from \"./gameobjects/Card\"\nimport Unit from \"./Unit\"\nimport Match from \"../../stages/Match\"\nimport { randomFloor } from \"../../math/math\"\nimport { Vector } from \"../../math/Vector\"\nimport { findPath } from \"../map/pathfinding\"\nimport Card from \"../card/Card\"\nimport Team from \"./Team\"\nimport Tile from \"../map/Tile\"\n\nexport default class AI {\n    //call timing\n    startTime: number | undefined\n    delay: number = 500\n\n    //stats\n    //Depth of thought, a thought counter but Kody didnt want me calling it depth...so Chodiness\n    chodiness: number\n    maxChodiness: number\n\n    constructor( maxChodiness = 8 ) {\n        this.chodiness = 0\n        this.maxChodiness = maxChodiness\n    }\n\n    think( team: Team ) {\n        this.startTime = Date.now()\n\n        let game = Game.instance\n        let { match } = game\n        let { cardTray } = match\n\n        this.chodiness += 1\n\n        if ( team.units.length > 0 && team.selectedUnitIndex > -1 && match.teams[0].length > 0 ) {\n            let unit = team.selectedUnit()!\n            let card = cardTray.selectedCard( unit )\n            let validCard = card && card.type.onApplyToTile\n            \n            if ( validCard ) {\n                // console.log(\"Card playability:\", card.type.playable)\n                let idealSpot: Vector | null = this.idealSpot( unit, card )\n                let enemies = this.getEnemiesOf( unit )\n                //step two: move within range\n                if ( idealSpot && !unit.pos.equals( idealSpot ) ) {\n                    if ( card.type.mobile ) {\n                        this.useCard( idealSpot )\n                    } else {\n                        this.moveTowards( unit, idealSpot )\n                    }\n                } else if ( enemies.length > 0 ) {\n                    let bestTarget = this.bestTargetOf( unit, card )\n                    if ( bestTarget ) {\n                        // console.log(\"using card in think\")\n                        this.useCard( bestTarget.pos )\n                    }\n                }\n            } else {\n                //Step ONE, select a card if available\n                this.selectBestCard( unit )\n            }\n        }\n        //resetting the timer\n    }\n    update() {\n        if ( this.startTime && Date.now() - this.startTime >= this.delay ) {\n            this.startTime = undefined\n            // console.log( \"Timing Out\" )\n        }\n    }\n    active() {\n        return this.startTime == undefined\n    }\n    reset() {\n        this.chodiness = 0;\n        this.startTime = undefined;\n    }\n    //---------------------UTILITY FUNCTIONS------------------------------\n    getEnemiesOf( unit: Unit ) {\n        let enemies: Unit[] = []\n        Game.instance.match.teams.forEach( ( team, index ) => {\n            if ( index !== unit.teamNumber ) {\n                team.units.forEach( unit => {\n                    enemies.push( unit )\n                } )\n            }\n        } )\n        return enemies\n    }\n    getFriendsOf( unit: Unit ) {\n        let friends: Unit[] = []\n        Game.instance.match.teams.forEach( ( team, index ) => {\n            if ( index == unit.teamNumber ) {\n                team.units.forEach( unit => {\n                    friends.push( unit )\n                } )\n            }\n        } )\n        return friends\n    }\n    bestTargetOf( unit: Unit, card: Card ) {\n        let enemies = this.possibleTargets( unit, card )\n        // console.log(\"Enemies:\", enemies)\n        let best\n        if ( enemies.length > 0 ) {\n            enemies.forEach( enemy => {\n                if ( best == undefined ) {\n                    best = enemy\n                } else if ( enemy.health < best.health ) {\n                    best = enemy\n                }\n            } )\n        }\n        return best\n    }\n    closestTargetTo(unit: Unit) {\n        let targets = this.getEnemiesOf(unit)\n        let closest\n        // console.log(\"enemies:\", this.getEnemiesOf(unit))\n        targets.forEach(target => {\n            if ( closest !== undefined) {\n                let best = closest.pos.distance(unit.pos)\n                let distance = target.pos.distance(unit.pos)\n                if (distance < best) {\n                    closest = target\n                }\n            } else {\n                closest = target\n            }\n        })\n        return closest\n    }\n    possibleTargets( unit: Unit, card: Card ) {\n        let game = Game.instance\n\n        let tiles = card.type.getTilesInRange( card, unit )\n        // console.log(\"tiles In Range: \", tiles)\n        let targets: Unit[] = []\n        let enemies = this.getEnemiesOf( unit )\n        let friends = this.getFriendsOf( unit )\n        tiles.forEach( tile => {\n            if ( card.type.friendly ) {\n                friends.forEach( friend => {\n                    if ( tile.x == friend.pos.x && tile.y == friend.pos.y ) {\n                        targets.push( friend )\n                    }\n                } )\n            } else {\n                enemies.forEach( enemy => {\n                    if ( tile.x == enemy.pos.x && tile.y == enemy.pos.y ) {\n                        targets.push( enemy )\n                    }\n                } )\n            }\n            // game.match\n            //return friendlies in list if card is helpful\n        } )\n        return targets\n    }\n    //-----------------------CARD FUNCTIONS----------------------\n    selectBestCard( unit: Unit ) {\n        let game = Game.instance\n        //using data from card currently selected, Unit will act\n        //random Choice will work for now though\n        //----------------AVOID CARDS THAT ARE UNPLAYABLE OR COST ABOVE YOUR ENERGY AVAILABLE\n        let playableCards: Card[] = []\n        unit.hand.cards.forEach( ( card: Card ) => {\n            if ( card.type.cost <= unit.energy && card.type.onApplyToTile ) {\n                playableCards.push( card )\n            }\n        } )\n\n        if ( playableCards.length > 0 ) {\n            let choice = playableCards[randomFloor( playableCards.length )]\n\n            let index = game.match.selectedUnit()!.hand.cards.indexOf(choice)\n            game.match.cardTray.selectIndex( index )\n        }\n    }\n    useCard( target: Vector ) {\n        let game = Game.instance\n        // console.log(\"Using card\")\n        game.match.applyCardAt( target )\n    }\n    //---------------------MOBILITY FUNCTIONS------------------------------\n    findCloseOrFarSpot( unit: Unit, target: Vector, close = true ) {\n        let game = Game.instance\n        let match = game.match\n        let record = unit.pos\n        let bar = 0\n        for ( let w = 0; w <= match.map.width; w++ ) {\n            for ( let h = 0; h <= match.map.height; h++ ) {\n                let spot = new Vector( w, h )\n                if ( match.isWalkable( spot ) ) {\n                    //How do?\n                    let path = findPath( match, target, spot )\n                    //if walkable, check to see if path is valid\n                    //either finds closest or farthest space\n                    if ( close ) {\n                        if ( path && path.length < bar ) {\n                            //make path from unit to target and if valid, save the tile and bar\n                            bar = path.length\n                            record = spot\n                        }\n                    } else {\n                        if ( path && path.length > bar ) {\n                            //make path from unit to target and if valid, save the tile and bar\n                            bar = path.length\n                            record = spot\n                        }\n                    }\n                }\n\n            }\n        }\n        return record\n    }\n    idealSpot( unit, card: Card ) {\n        let game = Game.instance\n        let match = game.match\n\n        //must find ideal distance, in the future this should take into account if unit should run away\n        let idealDist = card.type.range\n        //store closestTile\n        let enemies = this.getEnemiesOf( unit )\n        let targets = enemies\n        let closest: Vector | null = null\n\n        if ( card.type.friendly ) {\n            console.log(\"Unit's don't know how to use friendly cards\")\n        }\n        \n        if (card.type.mobile) {\n            let targetPos = this.closestTargetTo(unit).pos\n            let tiles = card.getTilesInRange(unit)\n            // console.log(\"unitpos:\", unit.pos)\n            // console.log(\"tiles:\", tiles)\n            tiles.forEach(tile => {\n                // console.log(\"distance:\", tile.distance(targetPos))\n                // console.log(\"targetPos:\", targetPos)\n                // console.log(\"tile:\", tile)\n                if ( closest ) {\n                    let best = closest.distance(targetPos)\n                    let distance = tile.distance(targetPos)\n                    if (distance < best) {\n                        // console.log(\"new closest:\", tile)\n                        closest = tile\n                    }\n                } else {\n                    closest = tile\n                }\n            })\n        } else {\n            targets.forEach( target => {\n                let tiles = card.getTilesInRange( target )\n                if (card.type.mobile) {\n                    tiles = card.getTilesInRange( unit )\n                }\n                tiles.forEach( tile => {\n                    let tilePath = findPath( match, unit.pos, tile )\n                    if (tilePath) {\n                        if ( closest == undefined ) {\n                            //if unnasigned and validPath\n                            let testPath = findPath( match, unit.pos, tile )\n                            if ( testPath !== undefined ) {\n                                closest = tile\n                            }\n                        } else {\n                            let closestPath = findPath( match, unit.pos, closest )\n                            if ( closestPath && tilePath.length < closestPath.length ) {\n                                closest = tile\n                            }\n                        }\n                    }\n                } )\n            } )\n        }\n\n        return closest\n    }\n    friendlySpace( unit ) {\n        let game = Game.instance\n        let match = game.match\n\n        let sightDistance = 20\n        let closest\n        match.teams[ unit.teamNumber ].units.forEach( friend => {\n            if ( friend.teamNumber == unit.teamNumber ) {\n                let tiles = targetsWithinRange( friend.pos, 0, sightDistance )\n                tiles.forEach( tile => {\n                    let tilePath = findPath( match, unit.pos, tile )\n                    if ( tilePath ) {\n                        if ( closest == undefined ) {\n                            //if unnasigned and validPath\n                            closest = tile\n                        } else {\n                            let closestPath = findPath( match, unit.pos, closest )\n                            if ( tilePath.length < closestPath!.length ) {\n                                closest = tile\n                            }\n                        }\n                    }\n                } )\n            }\n        } )\n        return closest\n    }\n    getPath( unit: Unit, location: Vector ) {\n        // console.log(\"UnitPOS:\", unit.pos, \"location:\", location)\n        let game = Game.instance\n        let match = game.match\n        let path = findPath( match, unit.pos, location, 100 )\n        // console.log(\"path:\", path)\n        return path\n    }\n    moveTowards( unit: Unit, location: Vector ) {\n        let game = Game.instance\n        let match = game.match\n        let closestSpace = this.findCloseOrFarSpot( unit, location )\n        let path = findPath( match, unit.pos, location )\n        // console.log(\"path:\", path)\n        // Unit should be either moving or using cards\n        if ( path ) {\n            let walkableLength = Math.min( path.length, unit.speed )\n            let walkablePath = path.slice( 0, walkableLength )\n            unit.walkPath( walkablePath )\n        } else {\n            console.log( \"Invlaid path request!\", unit.pos, \" cannot reach: \", location )\n        }\n    }\n}","import Game from \"../Game\"\nimport { clamp } from \"../math/math\"\nimport Matrix from \"../math/Matrix\"\nimport { Vector } from \"../math/Vector\"\nimport Scene from \"../common/Scene\"\nimport Match from \"../stages/Match\"\n\nexport default class Camera {\n    position: Vector\n    targetPosition?: Vector\n    velocity: Vector\n    get zoom() { return Math.SQRT2 ** this.zoomLevel }\n    zoomLevel: number\n    rotation: number\n    velocityDecay = 0.85\n    lastDragPosition?: Vector\n\n    constructor() {\n        //position should be 0, 0\n        this.position = new Vector( 600, 600 )\n        this.velocity = new Vector( 0, 0 )\n        //soomlevel should be 0\n        this.zoomLevel = -3\n        this.rotation = 0\n    }\n\n    worldToCamera( screenWidth: number, screenHeight: number ) {\n        let { x, y } = this.position\n        let { zoom, rotation } = this\n        return Matrix.transformation(\n            -x, -y,\n            -rotation,\n            zoom, zoom,\n            screenWidth / 2, screenHeight / 2\n        )\n    }\n    cameraToWorld( screenWidth: number, screenHeight: number ) { return this.worldToCamera( screenWidth, screenHeight ).inverse() }\n    worldPosition( screenWidth: number, screenHeight: number, screenPosition: Vector ) {\n        return this.cameraToWorld( screenWidth, screenHeight ).multiplyVec( screenPosition )\n    }\n\n    onKeyup( ev: KeyboardEvent ) {\n        if ( ev.key == \"=\" )\n            this.changeZoom( true )\n        if ( ev.key == \"-\" )\n            this.changeZoom( false )\n    }\n    onWheel( ev: WheelEvent ) {\n        this.changeZoom( Math.sign( ev.deltaY ) < 0 )\n    }\n    changeZoom( zoomIn: boolean ) {\n        let dz = zoomIn ? 1 : -1\n        this.zoomLevel = clamp( -4, 4, this.zoomLevel + dz )\n    }\n\n    update() {\n        let game = Game.instance\n        let { input } = game\n\n        let acceleration = 1 / this.zoom\n        if ( input.keys.get( \"w\" ) ) {\n            this.velocity.y += -acceleration\n            this.targetPosition = undefined\n        }\n        if ( input.keys.get( \"s\" ) ) {\n            this.velocity.y += acceleration\n            this.targetPosition = undefined\n        }\n        if ( input.keys.get( \"a\" ) ) {\n            this.velocity.x += -acceleration\n            this.targetPosition = undefined\n        }\n        if ( input.keys.get( \"d\" ) ) {\n            this.velocity.x += acceleration\n            this.targetPosition = undefined\n        }\n        let rotationSpeed = 0.01\n        if ( input.keys.get( \"]\" ) ) {\n            this.rotation += rotationSpeed\n        }\n        if ( input.keys.get( \"[\" ) ) {\n            this.rotation -= rotationSpeed\n        }\n\n        this.position = this.position.add( this.velocity )\n        this.velocity = this.velocity.scale( this.velocityDecay )\n        // if ( this.velocity.length < 0.5 ) {\n        //     this.velocity = new Vector( 0, 0 )\n        //     this.position.x |= 0\n        //     this.position.y |= 0\n        // }\n\n        if ( this.targetPosition ) {\n            let lerpTarget = this.position.lerp( this.targetPosition, 0.05 )\n            this.velocity = lerpTarget.subtract( this.position )\n            if ( this.isInFocusArea( this.targetPosition ) )\n                this.targetPosition = undefined\n        }\n\n        if ( this.lastDragPosition ) {\n            this.targetPosition = undefined\n            let cursor = input.cursor\n            let diff = this.lastDragPosition.subtract( cursor )\n            let mat = Scene.relativeMatrix( game.match.scene )\n            let diffPrime = mat.inverse().multiplyVec( diff, 0 )\n            this.velocity = diffPrime\n            this.lastDragPosition = cursor\n        }\n    }\n\n    startDragging() {\n        this.lastDragPosition = Game.instance.input.cursor\n    }\n\n    stopDragging() {\n        this.lastDragPosition = undefined\n    }\n\n    distFromViewport( pos: Vector ) {\n        let center = Game.instance.screenCenter()\n        let diff = pos.subtract( center )\n        let dx = Math.abs( diff.x ) - center.x\n        let dy = Math.abs( diff.y ) - center.y\n        return Math.max( dx, dy )\n    }\n    isInFocusArea( pos: Vector ) {\n        let screenDims = Game.instance.screenDimensions()\n        let pos2 = this.worldToCamera( screenDims.x, screenDims.y ).multiplyVec( pos )\n        return this.distFromViewport( pos2 ) < -Match.tileSize * 2\n    }\n    setCameraTarget( pos: Vector ) {\n        if ( this.isInFocusArea( pos ) )\n            return\n        this.targetPosition = pos\n    }\n}","import Grid from \"../gameobjects/map/Grid\"\nimport Graphics from \"../common/Graphics\"\nimport { Vector } from \"../math/Vector\"\nimport { findPath } from \"../gameobjects/map/pathfinding\"\nimport Game from \"../Game\"\nimport Matrix from \"../math/Matrix\"\nimport Scene, { SceneNode } from \"../common/Scene\"\nimport * as Tiles from \"../gameobjects/map/Tiles\"\nimport Team from \"../gameobjects/mech/Team\"\nimport CardTray from \"../gameobjects/ui/CardTray\"\nimport UnitTray from \"../gameobjects/ui/UnitTray\"\nimport { CardType, randomCardType, targetsWithinRange } from \"../gameobjects/card/CardTypes\"\nimport { Chrome, Earth, Flesh, Jelly, Treant } from \"../gameobjects/mech/RigTypes\"\nimport AI from \"../gameobjects/mech/AI\"\nimport { randomCeil, randomFloor } from \"../math/math\"\nimport { match } from \"assert\"\nimport Unit from \"../gameobjects/mech/Unit\"\nimport Camera from \"../gameobjects/Camera\"\nimport Card from \"../gameobjects/card/Card\"\n\n\nexport default class Match {\n    //Map\n    static tileSize = 32\n    map: Grid\n    camera = new Camera()\n\n    //timer\n    timer: number = 0\n\n    //Units\n    teams: Team[]\n    turn = 0\n\n    //UI\n    //should be ported to another class\n    cardTray = new CardTray()\n    unitTray = new UnitTray()\n\n    //ai\n    aiTeamNumbers = [ -1, 1 ]\n    ai = new AI()\n\n    //Card Animation\n    cardAnim = {\n        rate: 0.02,\n        cap: 1,\n        step: 1,\n        type: <CardType | undefined> undefined,\n        pos: <Vector> new Vector( 0, 0 )\n    }\n\n    //Node\n    scene: SceneNode = { localMatrix: Matrix.identity }\n\n    constructor( playerTeam: Team = Game.instance.team ) {\n        this.map = new Grid( 15, 15 )\n\n        this.teams = [\n            playerTeam,\n            new Team(\"Drunken Scholars\", [], true, 1)\n            // new Team( \"Thermate Embalmers\", true, 2 )\n        ]\n\n        window.addEventListener( \"keyup\", ev => this.onKeyup( ev ) )\n\n        //Move camera to first Unit\n        // this.moveCamToFirstUnit()\n    }\n\n    get units() {\n        let teams = this.teams\n        function* unitsGenerator() {\n            for ( let team of teams )\n                for ( let unit of team.units )\n                    yield unit\n        }\n        return unitsGenerator()\n    }\n    moveCamToUnit( unit: Unit ) {\n        if ( unit ) {\n            this.camera.setCameraTarget( unit.pos.addXY( .5, .5 ).scale( Match.tileSize ) )\n        }\n    }\n    moveCamToFirstUnit() {\n        let units = this.activeTeam().units\n        if ( units.length == 0 ) return\n        this.moveCamToUnit( units[ 0 ] )\n    }\n    generateMap() {\n        let randomTerrain = true\n        if ( randomTerrain ) {\n            this.map.newMap()\n            this.placeUnits()\n        } else {\n            //custom map\n            this.map.fillRect( new Vector( 3, 3 ), new Vector( 4, 4 ), Tiles.GrassHill )\n            this.map.fillRect( new Vector( 4, 4 ), new Vector( 2, 2 ), Tiles.Grass )\n            this.map.set( new Vector( 4, 3 ), Tiles.Grass )\n            this.map.set( new Vector( 5, 6 ), Tiles.Grass )\n        }\n    }\n    generateBoss() {\n        let enemies = <Unit[]> []\n        enemies.push(Game.instance.randomBoss)\n\n        let team = new Team( \"Drunken Scholars\", enemies, true, 1 )\n        return team\n    }\n    generateEnemies( funds: number ) {\n        let enemies = <Unit[]> []\n        funds += 1\n        let mechCost = 20\n        let cardCost = 5\n        let enemyTotal = randomCeil(funds / mechCost)\n        funds = funds - mechCost*enemyTotal\n        let bonusCardTotal = Math.floor( funds / cardCost )\n        \n        for (let i = 0; i < enemyTotal; i++) {\n            enemies.push(Game.instance.randomUnit)\n        }\n        if (enemyTotal)\n        for (let i = 0; i < bonusCardTotal; i++) {\n            let unit: Unit = enemies[randomFloor(enemies.length)]\n            let randomCard = new Card(randomCardType())\n            unit.draw.cards.push(randomCard)\n        }\n        enemies.forEach(enemy => {\n            enemy.statReset()\n        });\n        let team = new Team( \"Drunken Scholars\", enemies, true, 1 )\n        return team\n    }\n\n    playerTurn() {\n        return this.turn == 0\n    }\n    placeUnits() {\n        this.teams.forEach( team => {\n            this.map.placeUnits( team.units )\n        } )\n    }\n    activeTeam() { return this.teams[ this.turn ] }\n    playerUnits() { return this.teams[ 0 ].units }\n    // enemyUnits() { return this.teams[1].units }\n    selectedUnit() { return this.activeTeam().selectedUnit() }\n    selectedCard() { return this.selectedUnit()?.hand.cards[ this.cardTray.index ] }\n    isPickingCard() { return this.cardTray.isPickingTarget }\n    goBack() {\n        let { unitTray, cardTray } = this\n        if ( cardTray.isPickingTarget )\n            cardTray.deselect()\n        else\n            this.activeTeam().deselect()\n    }\n    applyCardAt( pos: Vector ) {\n        let unit = this.selectedUnit()\n        let card = this.selectedCard()\n        this.cardTray.deselect()\n        if ( unit && card ) {\n            let costs = {\n                energy: card.type.cost == undefined ? 0 : card.type.cost,\n                speed: card.type.speedCost == undefined ? 0 : card.type.speedCost,\n                // health: card.type.healthCost == undefined ? 0 : card.type.healthCost,\n            }\n            let isEnoughEnergy = unit.energy >= costs.energy\n            let isEnoughSpeed = unit.speed >= costs.speed\n            if ( isEnoughEnergy && isEnoughSpeed ) {\n                let index = unit.hand.cards.indexOf( card )\n                if ( index < 0 )\n                    throw new Error( \"Selected card is not in selected unit's hand.\" )\n                unit.hand.cards.splice( index, 1 )\n                if ( !card.type.exhaustive ) {\n                    unit.discard.cards.push( card )\n                }\n                card.apply( unit, pos )\n\n                //Triggers Card Animtaion\n                this.animateCard(pos, card.type)\n            }\n        }\n    }\n    animateCard(pos: Vector, type: CardType) {\n        this.cardAnim.step = 0\n        this.cardAnim.type = type\n        this.cardAnim.pos = pos\n    }\n\n    getUnit( pos: Vector ) {\n        for ( let team of this.teams ) {\n            for ( let unit of team.units )\n                if ( unit.pos.equals( pos ) )\n                    return unit\n        }\n    }\n\n    isWalkable( pos: Vector, checkUnits = true ) {\n        if ( checkUnits && this.getUnit( pos ) )\n            return false\n        return this.map.contains( pos ) && this.map.isEmpty( pos )\n    }\n\n    hasFocus() {\n        return Game.instance.mouseOverData.node?.description == \"match\"\n    }\n\n    tileSpaceCursor() {\n        let cursor = Game.instance.input.cursor\n        return Scene.toLocalSpace( cursor, this.scene ).scale( 1 / Match.tileSize ).floor()\n    }\n\n    endTurn() {\n        // Health ReCapped at turn start\n        // console.log( \"Ending turn\" )\n        this.teams[ this.turn ].endTurn()\n        this.turn++\n        this.turn %= this.teams.length\n        this.teams[ this.turn ].startTurn()\n        this.timer += 1\n\n        if (this.playerUnits().length == 0) {\n            Game.instance.changeStage(\"lose\")\n        }\n        if ( this.teams[ 1 ].units.length == 0 ) {\n            let game = Game.instance\n            //----GO Shopping!------\n            game.match.turn = 0\n            game.scrip += game.scripReward\n            game.changeStage(\"route\")\n        } else {\n            // Team Selection\n            this.activeTeam().cycleUnits()\n            this.moveCamToUnit( this.activeTeam().selectedUnit()! )\n        }\n    }\n    start() {\n        let game = Game.instance\n        \n        //----GO Fighting!------\n        this.teams[ 0 ] = game.team\n        game.team.units.forEach( unit => {\n            unit.statReset()\n        } )\n        this.map = new Grid( 15, 15 )\n        //Generate enemies to fight\n        let funds = Math.floor(game.level * 11.5)\n        this.teams[ 1 ] = this.generateEnemies(funds)\n        this.generateMap()\n        this.turn = 0\n        this.activeTeam().cycleUnits()\n        if ( this.activeTeam().selectedUnit() ) {\n            this.moveCamToUnit( this.activeTeam().selectedUnit()! )\n        }\n        this.turn = 0\n        //Toggle!\n        game.activity = \"match\"\n    }\n    startBoss() {\n        let game = Game.instance\n        \n        //----GO Fighting!------\n        this.teams[ 0 ] = game.team\n        game.team.units.forEach( unit => {\n            unit.statReset()\n        } )\n        this.map = new Grid( 15, 15 )\n        //Generate enemies to fight\n        this.teams[ 1 ] = this.generateBoss()\n        this.generateMap()\n        this.turn = 0\n        this.activeTeam().cycleUnits()\n        if ( this.activeTeam().selectedUnit() ) {\n            this.moveCamToUnit( this.activeTeam().selectedUnit()! )\n        }\n        this.turn = 0\n        //Toggle!\n        game.activity = \"match\"\n    }\n    onMousedown( ev: MouseEvent ) {\n        let game = Game.instance\n        let button = ev.button\n        let leftClick = button == 0\n        let middleClick = button == 1\n        let rightClick = button == 2\n        if ( leftClick || middleClick ) {\n            let cursor = game.input.cursor\n            let node = Scene.pickNode( this.scene, cursor )\n            let worldClicked = node == this.scene\n            let nothingClicked = node == undefined\n            let unitSelected = this.activeTeam().selectedUnit() !== undefined\n            let isMovingUnit = unitSelected && !this.isPickingCard()\n            let canLeftClickDrag = ( ( worldClicked || nothingClicked ) && !isMovingUnit ) || game.input.keys.get( \"shift\" )\n            if ( canLeftClickDrag || middleClick )\n                this.camera.startDragging()\n        } else if ( rightClick ) {\n            this.goBack()\n        }\n    }\n    onMouseup( ev: MouseEvent ) {\n        this.camera.stopDragging()\n        console.log(ev)\n    }\n    onWheel( ev: WheelEvent ) {\n        this.camera.onWheel( ev )\n    }\n\n    onKeyup( ev: KeyboardEvent ) {\n        this.camera.onKeyup( ev )\n        if (Game.instance.activity == \"match\") {\n            if (this.playerTurn()) {\n                if ( ev.key == \"Tab\" ) {\n                    this.activeTeam().cycleUnits()\n                }\n                if ( ev.key == \"Escape\" ) {\n                    this.goBack()\n                }\n                if ( ev.key == \"Enter\" ) {\n                    // console.log(\"logging enter!\")\n                    this.endTurn()\n                }\n            }\n        }\n    }\n\n    update() {\n        this.camera.update()\n        this.teams.forEach( team => {\n            team.update()\n        } )\n\n        //Match exit\n        if (this.teams[0].length == 0 || this.teams[1].length == 0) {\n            this.endTurn()\n        }\n\n        if ( this.activeTeam().selectedUnit() ) {\n            this.cardTray.update( this.activeTeam().selectedUnit()! )\n        }\n        let { step, cap, type } = this.cardAnim\n        if ( step < cap ) {\n            if ( type ) {\n                let rate = type.renderFrames ? this.cardAnim.cap / type.renderFrames : 0.1\n                this.cardAnim.step += rate\n            }\n        }\n\n        if ( !this.playerTurn() ) {\n            let AI = this.ai\n            AI.update()\n            if ( AI.startTime == undefined ) {\n                AI.think( this.activeTeam() )\n            }\n            if ( AI.chodiness >= AI.maxChodiness ) {\n                if ( this.activeTeam().selectedUnitIndex >= this.activeTeam().units.length - 1 ) {\n                    this.endTurn()\n                    this.activeTeam().cycleUnits()\n                    if ( this.playerUnits.length > 0 )\n                        this.moveCamToUnit( this.selectedUnit()! )\n                    AI.reset()\n                } else {\n                    this.activeTeam().cycleUnits()\n                    this.moveCamToUnit( this.selectedUnit()! )\n                    AI.reset()\n                }\n            }\n        }\n    }\n\n    // View\n    render() {\n        let g = Graphics.instance\n        let game = Game.instance\n        let tileSize = Match.tileSize\n\n        if ( this.camera.zoom * Game.uiScale <= 1.5 ) {\n            g.c.imageSmoothingEnabled = true\n            g.c.imageSmoothingQuality = \"low\"\n        }\n\n        //  Draws the match tiles\n        this.drawMap()\n\n        let cursor = this.tileSpaceCursor()\n        let selectedUnit = this.activeTeam().selectedUnit()\n        let cursorWalkable = this.isWalkable( cursor )\n\n        // let elevation = this.map.getElevation( cursor )\n        // console.log( elevation )\n\n        //  Draw unit path\n        if ( this.playerTurn() ) {\n            if ( this.hasFocus() && cursorWalkable && selectedUnit != undefined && this.cardTray.index == -1 && selectedUnit.speed > 0) {\n                let walkableTiles = targetsWithinRange( selectedUnit.pos, 0, selectedUnit.speed )\n                walkableTiles.forEach( tile => {\n                    let path = findPath( this, selectedUnit!.pos, tile, selectedUnit!.speed )\n                    if ( path && path.length <= selectedUnit!.speed ) {\n\n                        g.drawRect( tile.scale( tileSize ), new Vector( tileSize, tileSize ), \"rgba(0, 0, 255, 0.1)\" )\n                        g.strokeRect( tile.scale( tileSize ), new Vector( tileSize, tileSize ), \"rgba(0, 0, 255, 0.1)\" )\n                    }\n                } )\n                let path = findPath( this, selectedUnit.pos, cursor, 100 )\n                if ( path && selectedUnit.canMove() ) {\n                    let pathLength = path.length\n                    let walkableLength = Math.min( path.length, selectedUnit.speed )\n                    let trimmedSteps = path.slice( walkableLength - 1 )\n                    let walkablePath = path.slice( 0, walkableLength )\n                    path.length = walkableLength\n                    let radius = 3\n                    g.c.save()\n                    {\n                        // const walkableColor = \"rgb(30, 125, 30)\", unwalkableColor = \"#c9c5b955\"\n                        const walkableColor = \"rgb(0, 240, 0)\", unwalkableColor = \"#c9c5b955\"\n                        let pathBacking = \"rgb(30, 115, 30)\"\n                        g.makePath( walkablePath.map( x => x.add( Vector.one.scale( 0.5 ) ).scale( tileSize ) ) )\n                        g.c.strokeStyle = pathBacking\n                        g.c.lineWidth = radius + 2\n                        g.c.stroke()\n                        g.c.strokeStyle = walkableColor\n                        g.c.lineWidth = radius\n                        g.c.stroke()\n\n                        let pathTooLong = walkableLength != pathLength\n                        if ( pathTooLong ) {\n                            g.makePath( trimmedSteps.map( x => x.add( Vector.one.scale( 0.5 ) ).scale( tileSize ) ) )\n                            g.c.strokeStyle = unwalkableColor\n                            g.c.lineWidth = radius\n                            g.c.stroke()\n                            g.c.setLineDash( [] )\n\n                            g.c.beginPath()\n                            let endpoint = cursor.add( Vector.one.scale( 0.5 ) ).scale( tileSize )\n                            g.c.fillStyle = unwalkableColor\n                            g.c.fillRect( endpoint.x - radius, endpoint.y - radius, radius * 2, radius * 2 )\n                        }\n\n                        g.c.beginPath()\n                        let endpoint = path[ path.length - 1 ].add( Vector.one.scale( 0.5 ) ).scale( tileSize )\n                        g.c.fillStyle = walkableColor\n                        g.c.fillRect( endpoint.x - radius, endpoint.y - radius, radius * 2, radius * 2 )\n                    }\n                    g.c.restore()\n                }\n            }\n        }\n\n        //Card Animation\n        let { step, cap, type, pos } = this.cardAnim\n        if ( selectedUnit ) {\n            if ( step < cap ) {\n                //--------------------------CARD ANIMATION SHOULD GO HERE, THEN INCREASE STEP BY RATE IN UPDATE\n                if ( type?.render ) {\n                    if ( selectedUnit ) {\n                        // console.log(\"USING CARD ANIMATION\")\n                        type.render( step, selectedUnit, pos )\n                    }\n                }\n            }\n        }\n    }\n\n    drawMap( numbered: boolean = false ) {\n        let g = Graphics.instance\n        let map = this.map\n        let tileSize = Match.tileSize\n        for ( let y = 0; y < map.height; y++ ) {\n            for ( let x = 0; x < map.width; x++ ) {\n                let currentPos = new Vector( x * tileSize, y * tileSize )\n                let tile = map.getFromXY( x, y )\n                if ( tile.getElevation() <= 0 ) {\n                    tile.render( currentPos.x, currentPos.y )\n                }\n            }\n        }\n        for ( let y = 0; y < map.height; y++ ) {\n            for ( let x = 0; x < map.width; x++ ) {\n                let currentPos = new Vector( x * tileSize, y * tileSize )\n                let tile = map.getFromXY( x, y )\n                if ( tile.getElevation() >= 0 ) {\n                    Tiles.Grass.render( currentPos.x, currentPos.y )\n                    tile.render( currentPos.x, currentPos.y )\n                }\n                if ( numbered ) {\n                    let textPos = new Vector( x * tileSize + 1, y * tileSize + 1 )\n                    let currentText = x.toString() + \", \" + y.toString()\n                    g.setFont( tileSize / 8 | 0, \"pixel\" )\n                    g.drawText( textPos, currentText, \"#f0ead8\" )\n                }\n            }\n        }\n    }\n\n    makeSceneNode() {\n        let game = Game.instance\n        let g = Graphics.instance\n        // let { units } = this\n        let { teams } = this\n        let { width, height } = this.map\n        let selectedUnit = this.activeTeam().selectedUnit()\n        // let pickingTarget = false\n        let pickingCard = this.isPickingCard()\n        let tileSize = Match.tileSize\n\n        this.scene = Scene.node( {\n            description: \"match\",\n            localMatrix: this.cameraTransform(),\n            rect: { width: width * tileSize, height: height * tileSize, },\n            onClick: ( node, pos: Vector ) => {\n                if ( this.playerTurn() ) {\n                    if ( selectedUnit && selectedUnit.canMove() && !pickingCard ) {\n                        let cell = pos.scale( 1 / tileSize ).floor()\n                        let path = findPath( this, selectedUnit.pos, cell, 100 )\n                        if ( path ) {\n                            path.length = Math.min( path.length, selectedUnit.speed )\n                            selectedUnit.walkPath( path )\n                        }\n                    }\n                }\n            },\n            content: () => {\n                for ( let unit of this.units )\n                    unit.makeSceneNode()\n\n                if ( pickingCard ) {\n                    let card = this.selectedCard()\n                    if ( selectedUnit && card ) {\n                        for ( let pos of card?.getTilesInRange( selectedUnit ) ) {\n                            let unit = this.getUnit( pos )\n                            let isValidTarget = unit || card?.type.canApplyToEmptyTiles\n                            Scene.node( {\n                                description: \"card-target\",\n                                localMatrix: Matrix.vTranslation( pos.scale( tileSize ) ),\n                                rect: { width: tileSize, height: tileSize },\n                                onClick: () => {\n                                    if ( this.playerTurn() && isValidTarget ) {\n                                        this.applyCardAt( pos )\n                                    }\n                                },\n                                onRender: ( node ) => {\n                                    let hover = node == game.mouseOverData.node\n                                    let highlight = hover && isValidTarget\n                                    let alpha = isValidTarget ? .5 : .15\n                                    let highlightTarget = `rgba(135, 231, 255, ${ alpha })`\n                                    let possibleTarget = `rgba(3, 202, 252, ${ alpha })`\n                                    g.c.fillStyle = highlight ? highlightTarget : possibleTarget\n                                    let cardImpactZone = [ pos ]\n                                    if ( Game.instance.match.map.contains( pos ) ) {\n                                        if ( card?.type.getTilesEffected ) {\n                                            cardImpactZone = card?.type.getTilesEffected!( this.selectedUnit()!, pos )\n                                        }\n                                        if ( highlight ) {\n                                            cardImpactZone.forEach( ( tile, i ) => {\n                                                let adjustedPos = new Vector( tile.x, tile.y ).subtract( pos ).scale( tileSize )\n                                                g.c.fillStyle = highlight ? highlightTarget : possibleTarget\n                                                g.c.strokeStyle = `rgba(0, 173, 217, ${ alpha })`\n                                                g.c.beginPath()\n                                                g.c.rect( adjustedPos.x, adjustedPos.y, tileSize, tileSize )\n                                                g.c.fill()\n                                                g.c.stroke()\n                                            } )\n                                        }\n                                        g.c.strokeStyle = `rgba(0, 173, 217, ${ alpha })`\n                                        g.c.beginPath()\n                                        g.c.rect( 0, 0, tileSize, tileSize )\n                                        g.c.fill()\n                                        g.c.stroke()\n                                        unit?.drawStats()\n                                    }\n                                }\n                            } )\n                        }\n                    }\n                }\n            },\n            onRender: () => this.render(),\n        } )\n    }\n    cameraTransform() {\n        let game = Game.instance\n        let screenDims = game.screenDimensions()\n        return this.camera.worldToCamera( screenDims.x, screenDims.y )\n    }\n}","import { Vector } from \"../math/Vector\"\n\nexport default class Input {\n    static instance: Input\n    keys: Map<string, boolean>\n    codes: Map<string, boolean>\n    mouse: Map<number, boolean>\n    cursor: Vector\n    constructor() {\n        Input.instance = this\n\n        this.keys = new Map()\n        this.codes = new Map()\n        this.mouse = new Map()\n        this.cursor = new Vector( 0, 0 )\n\n        window.addEventListener( \"mousedown\", e => this.mouse.set( e.button, true ) )\n        window.addEventListener( \"mouseup\", e => this.mouse.set( e.button, false ) )\n        window.addEventListener( \"keydown\", e => {\n            this.keys.set( e.key.toLowerCase(), true )\n            this.codes.set( e.code, true )\n        } )\n        window.addEventListener( \"keyup\", e => {\n            this.keys.set( e.key.toLowerCase(), false )\n            this.codes.set( e.code, false )\n        } )\n        window.addEventListener( \"mousemove\", e => this.cursor = new Vector( e.x, e.y ) )\n    }\n}","import { lerp } from \"../math/math\"\n\nexport default class Clock {\n    static instance: Clock\n    lastFrame: number\n    averageFPS: number\n    dt: number\n    constructor() {\n        Clock.instance = this\n        this.lastFrame = performance.now()\n        this.averageFPS = 0\n        this.dt = 16\n    }\n    get dtSeconds() {\n        return this.dt / 1000\n    }\n    nextFrame() {\n        let now = performance.now()\n        let dt = now - this.lastFrame\n        this.dt = dt\n        this.lastFrame = now\n        if ( dt != 0 ) {\n            let FPS = 1000 / dt\n            this.averageFPS = lerp( this.averageFPS, FPS, 0.04 )\n        }\n        return dt\n    }\n}","const names = `\n    Michael\n    Christopher\n    Jessica\n    Matthew\n    Ashley\n    Jennifer\n    Joshua\n    Amanda\n    Daniel\n    David\n    James\n    Robert\n    John\n    Joseph\n    Andrew\n    Ryan\n    Brandon\n    Jason\n    Justin\n    Sarah\n    William\n    Jonathan\n    Stephanie\n    Brian\n    Nicole\n    Nicholas\n    Anthony\n    Heather\n    Eric\n    Elizabeth\n    Adam\n    Megan\n    Melissa\n    Kevin\n    Steven\n    Thomas\n    Timothy\n    Christina\n    Kyle\n    Rachel\n    Laura\n    Lauren\n    Amber\n    Brittany\n    Danielle\n    Richard\n    Kimberly\n    Jeffrey\n    Amy\n    Crystal\n    Michelle\n    Tiffany\n    Jeremy\n    Benjamin\n    Mark\n    Emily\n    Aaron\n    Charles\n    Rebecca\n    Stephen\n    Patrick\n    Sean\n    Erin\n    Zachary\n    Jamie\n    Kelly\n    Samantha\n    Nathan\n    Sara\n    Dustin\n    Paul\n    Angela\n    Tyler\n    Scott\n    Katherine\n    Andrea\n    Gregory\n    Erica\n    Mary\n    Travis\n    Lisa\n    Kenneth\n    Bryan\n    Lindsey\n    Kristen\n    Jose\n    Alexander\n    Jesse\n    Katie\n    Lindsay\n    Shannon\n    Vanessa\n    Courtney\n    Christine\n    Alicia\n    Allison\n    Bradley\n    Samuel\n    Shawn\n    April\n    Derek\n    Kathryn\n    Kristin\n    Chad\n    Jenna\n    Tara\n    Maria\n    Krystal\n    Jared\n    Anna\n    Edward\n    Julie\n    Peter\n    Holly\n    Marcus\n    Kristina\n    Natalie\n    Jordan\n    Victoria\n    Jacqueline\n    Corey\n    Keith\n    Monica\n    Juan\n    Donald\n    Cassandra\n    Meghan\n    Joel\n    Shane\n    Phillip\n    Patricia\n    Brett\n    Ronald\n    Catherine\n    George\n    Antonio\n    Cynthia\n    Stacy\n    Kathleen\n    Raymond\n    Carlos\n    Brandi\n    Douglas\n    Nathaniel\n    Ian\n    Craig\n    Brandy\n    Alex\n    Valerie\n    Veronica\n    Cory\n    Whitney\n    Gary\n    Derrick\n    Philip\n    Luis\n    Diana\n    Chelsea\n    Leslie\n    Caitlin\n    Leah\n    Natasha\n    Erika\n    Casey\n    Latoya\n    Erik\n    Dana\n    Victor\n    Brent\n    Dominique\n    Frank\n    Brittney\n    Evan\n    Gabriel\n    Julia\n    Candice\n    Karen\n    Melanie\n    Adrian\n    Stacey\n    Margaret\n    Sheena\n    Wesley\n    Vincent\n    Alexandra\n    Katrina\n    Bethany\n    Nichole\n    Larry\n    Jeffery\n    Curtis\n    Carrie\n    Todd\n    Blake\n    Christian\n    Randy\n    Dennis\n    Alison\n    Trevor\n    Seth\n    Kara\n    Joanna\n    Rachael\n    Luke\n    Felicia\n    Brooke\n    Austin\n    Candace\n    Jasmine\n    Jesus\n    Alan\n    Susan\n    Sandra\n    Tracy\n    Kayla\n    Nancy\n    Tina\n    Krystle\n    Russell\n    Jeremiah\n    Carl\n    Miguel\n    Tony\n    Alexis\n    Gina\n    Jillian\n    Pamela\n    Mitchell\n    Hannah\n    Renee\n    Denise\n    Molly\n    Jerry\n    Misty\n    Mario\n    Johnathan\n    Jaclyn\n    Brenda\n    Terry\n    Lacey\n    Shaun\n    Devin\n    Heidi\n    Troy\n    Lucas\n    Desiree\n    Jorge\n    Andre\n    Morgan\n    Drew\n    Sabrina\n    Miranda\n    Alyssa\n    Alisha\n    Teresa\n    Johnny\n    Meagan\n    Allen\n    Krista\n    Marc\n    Tabitha\n    Lance\n    Ricardo\n    Martin\n    Chase\n    Theresa\n    Melinda\n    Monique\n    Tanya\n    Linda\n    Kristopher\n    Bobby\n    Caleb\n    Ashlee\n    Kelli\n    Henry\n    Garrett\n    Mallory\n    Jill\n    Jonathon\n    Kristy\n    Anne\n    Francisco\n    Danny\n    Robin\n    Lee\n    Tamara\n    Manuel\n    Meredith\n    Colleen\n    Lawrence\n    Christy\n    Ricky\n    Randall\n    Marissa\n    Ross\n    Mathew\n    Jimmy\n    Abigail\n    Kendra\n    Carolyn\n    Billy\n    Deanna\n    Jenny\n    Jon\n    Albert\n    Taylor\n    Lori\n    Rebekah\n    Cameron\n    Ebony\n    Wendy\n    Angel\n    Micheal\n    Kristi\n    Caroline\n    Colin\n    Dawn\n    Kari\n    Clayton\n    Arthur\n    Roger\n    Roberto\n    Priscilla\n    Darren\n    Kelsey\n    Clinton\n    Walter\n    Louis\n    Barbara\n    Isaac\n    Cassie\n    Grant\n    Cristina\n    Tonya\n    Rodney\n    Bridget\n    Joe\n    Cindy\n    Oscar\n    Willie\n    Maurice\n    Jaime\n    Angelica\n    Sharon\n    Julian\n    Jack\n    Jay\n    Calvin\n    Marie\n    Hector\n    Kate\n    Adrienne\n    Tasha\n    Michele\n    Ana\n    Stefanie\n    Cara\n    Alejandro\n    Ruben\n    Gerald\n    Audrey\n    Kristine\n    Ann\n    Shana\n    Javier\n    Katelyn\n    Brianna\n    Bruce\n    Deborah\n    Claudia\n    Carla\n    Wayne\n    Roy\n    Virginia\n    Haley\n    Brendan\n    Janelle\n    Jacquelyn\n    Beth\n    Edwin\n    Dylan\n    Dominic\n    Latasha\n    Darrell\n    Geoffrey\n    Savannah\n    Reginald\n    Carly\n    Fernando\n    Ashleigh\n    Aimee\n    Regina\n    Mandy\n    Sergio\n    Rafael\n    Pedro\n    Janet\n    Kaitlin\n    Frederick\n    Cheryl\n    Autumn\n    Tyrone\n    Martha\n    Omar\n    Lydia\n    Jerome\n    Theodore\n    Abby\n    Neil\n    Shawna\n    Sierra\n    Nina\n    Tammy\n    Nikki\n    Terrance\n    Donna\n    Claire\n    Cole\n    Trisha\n    Bonnie\n    Diane\n    Summer\n    Carmen\n    Mayra\n    Jermaine\n    Eddie\n    Micah\n    Marvin\n    Levi\n    Emmanuel\n    Brad\n    Taryn\n    Toni\n    Jessie\n    Evelyn\n    Darryl\n    Ronnie\n    Joy\n    Adriana\n    Ruth\n    Mindy\n    Spencer\n    Noah\n    Raul\n    Suzanne\n    Sophia\n    Dale\n    Jodi\n    Christie\n    Raquel\n    Naomi\n    Kellie\n    Ernest\n    Jake\n    Grace\n    Tristan\n    Shanna\n    Hilary\n    Eduardo\n    Ivan\n    Hillary\n    Yolanda\n    Alberto\n    Andres\n    Olivia\n    Armando\n    Paula\n    Amelia\n    Sheila\n    Rosa\n    Robyn\n    Kurt\n    Dane\n    Glenn\n    Nicolas\n    Gloria\n    Eugene\n    Logan\n    Steve\n    Ramon\n    Bryce\n    Tommy\n    Preston\n    Keri\n    Devon\n    Alana\n    Marisa\n    Melody\n    Rose\n    Barry\n    Marco\n    Karl\n    Daisy\n    Leonard\n    Randi\n    Maggie\n    Charlotte\n    Emma\n    Terrence\n    Justine\n    Britney\n    Lacy\n    Jeanette\n    Francis\n    Tyson\n    Elise\n    Sylvia\n    Rachelle\n    Stanley\n    Debra\n    Brady\n    Charity\n    Hope\n    Melvin\n    Johanna\n    Karla\n    Jarrod\n    Charlene\n    Gabrielle\n    Cesar\n    Clifford\n    Byron\n    Terrell\n    Sonia\n    Julio\n    Stacie\n    Shelby\n    Shelly\n    Edgar\n    Roxanne\n    Dwayne\n    Kaitlyn\n    Kasey\n    Jocelyn\n    Alexandria\n    Harold\n    Esther\n    Kerri\n    Ellen\n    Abraham\n    Cedric\n    Carol\n    Katharine\n    Shauna\n    Frances\n    Antoine\n    Tabatha\n    Annie\n    Erick\n    Alissa\n    Sherry\n    Chelsey\n    Franklin\n    Branden\n    Helen\n    Traci\n    Lorenzo\n    Dean\n    Sonya\n    Briana\n    Angelina\n    Trista\n    Bianca\n    Leticia\n    Tia\n    Cody\n    Kristie\n    Stuart\n    Laurie\n    Harry\n    Leigh\n    Elisabeth\n    Alfredo\n    Aubrey\n    Ray\n    Arturo\n    Joey\n    Kelley\n    Max\n    Andy\n    Latisha\n    Johnathon\n    India\n    Eva\n    Ralph\n    Yvonne\n    Warren\n    Kirsten\n    Miriam\n    Kelvin\n    Lorena\n    Staci\n    Anita\n    Rene\n    Cortney\n    Orlando\n    Carissa\n    Jade\n    Camille\n    Leon\n    Paige\n    Marcos\n    Elena\n    Brianne\n    Dorothy\n    Marshall\n    Daryl\n    Colby\n    Terri\n    Gabriela\n    Brock\n    Gerardo\n    Jane\n    Nelson\n    Tamika\n    Alvin\n    Chasity\n    Trent\n    Jana\n    Enrique\n    Tracey\n    Antoinette\n    Jami\n    Earl\n    Gilbert\n    Damien\n    Janice\n    Christa\n    Tessa\n    Kirk\n    Yvette\n    Elijah\n    Howard\n    Elisa\n    Desmond\n    Clarence\n    Alfred\n    Darnell\n    Breanna\n    Kerry\n    Nickolas\n    Maureen\n    Karina\n    Roderick\n    Rochelle\n    Rhonda\n    Keisha\n    Irene\n    Ethan\n    Alice\n    Allyson\n    Hayley\n    Trenton\n    Beau\n    Elaine\n    Demetrius\n    Cecilia\n    Annette\n    Brandie\n    Katy\n    Tricia\n    Bernard\n    Wade\n    Chance\n    Bryant\n    Zachery\n    Clifton\n    Julianne\n    Angelo\n    Elyse\n    Lyndsey\n    Clarissa\n    Meaghan\n    Tanisha\n    Ernesto\n    Isaiah\n    Xavier\n    Clint\n    Jamal\n    Kathy\n    Salvador\n    Jena\n    Marisol\n    Darius\n    Guadalupe\n    Chris\n    Patrice\n    Jenifer\n    Lynn\n    Landon\n    Brenton\n    Sandy\n    Leif\n    Leif\n    Leif\n    Kaden\n    Kaden\n    Kaden\n    Chase\n    Orion\n    Orion\n    Orion\n    Orion\n    Orion\n    Orion\n    Orion\n    Orion\n    Kody\n    Kody\n    Kody\n    Kody\n    Jaycob\n    Jaycob\n    Jaycob\n    Jaycob`\n    .split( \"\\n\" ).map( x => x.trim() ) as string[]\n\nexport default names","import { Vector } from \"../../math/Vector\";\nimport Card from \"./Card\";\nimport { CardType } from \"./CardTypes\";\n\nexport class Deck {\n\n    max: number = 69\n    cards: Card[] = []\n    pos: Vector\n    offset: Vector\n    constructor( total: number = 0 ) {\n\n        this.pos = Vector.zero\n        this.offset = new Vector(1, 1)\n\n        for ( let i = 0; i < total; i++ ) {\n            let card = new Card()\n            this.cards.push( card )\n        }\n    }\n\n    get length() {\n        return this.cards.length\n    }\n    typeCount( type: CardType ) {\n        let count = 0\n        this.cards.forEach( card => {\n            if (card.type == type) {\n                count += 1\n            }\n        })\n        return count\n    }\n    insertAt( card: Card, index: number ) {\n        if ( this.length == 0 ) {\n            this.cards.push( card )\n            return\n        }\n        let store = this.cards[ index ]\n        this.cards[ index ] = card\n        this.cards.push( store )\n    }\n    insertAtRandom( card: Card ) {\n        let random = Math.floor( Math.random() * this.length )\n        this.insertAt( card, random )\n    }\n    add( cardType: CardType, count: number = 1 ) {\n        for ( let i = 0; i < count; i++ ) {\n            let card = new Card(cardType)\n            this.insertAtRandom(card)\n        }\n    }\n    addCard( card: Card ) {\n        if (this.cards.length < this.max) {\n            this.cards.push(card);\n        }\n    }\n    addCards( cards: Card[] ) {\n        cards.forEach(card => {\n            this.addCard(card);\n        });\n    }\n    addCardsatRandom( cards: Card[] ) {\n        cards.forEach(card => {\n            this.insertAtRandom(card);\n        });\n    }\n\n    removeCards( desired: number ) {\n        let count = desired > this.length ? this.length : desired;\n        let cards: Card[] = [];\n        for (let i = 0; i < count; i++) {\n            cards.push(this.cards.pop()!)\n        }\n        return cards;\n    }\n    emptyInto(deck: Deck) {\n        if (this.length > 0) {\n            deck.addCardsatRandom(this.removeCards(this.length));\n        } else {\n            console.log(\"Deck already empty:\", deck)\n        }\n    }\n\n    fillFrom(deck: Deck) {\n        let {max, length} = this;\n        if (length < max) {\n            // console.log(\"Filling Hand\");\n            let drawTotal = length == max ? max : max - length;\n            this.addCards(deck.removeCards(drawTotal));\n        } else {\n            console.log(\"already full:\", deck)\n        }\n    }\n    fillTill(deck: Deck, cap: number = this.length) {\n        let { length } = this;\n        cap = cap < this.max ? cap : this.max\n        if (length < cap) {\n            // console.log(\"Filling Hand\");\n            let drawTotal = length == cap ? cap : cap - length;\n            this.addCards(deck.removeCards(drawTotal));\n        } else {\n            console.log(\"Already full:\", deck)\n        }\n    }\n    drawTill(that: Deck, amount: number) {\n        if (amount > that.length) {\n            amount = that.length\n        }\n        for (let i = 0; i < amount; i++) {\n            if (that.cards.length > 0) {\n                let card = that.cards.pop()!\n                this.cards.push(card)\n            }\n        }\n    }\n    cardPosition( cardIndex: number ) {\n        let { pos, offset } = this\n        return pos.addXY( cardIndex * offset.x , cardIndex * offset.y )\n    }\n}","import { clamp, randomFloor, randomInt } from \"../../math/math\"\nimport { Vector } from \"../../math/Vector\"\nimport Matrix from \"../../math/Matrix\"\nimport Input from \"../../common/Input\"\nimport Graphics, { TextAlignX, TextAlignY } from \"../../common/Graphics\"\nimport names from \"../../common/names\"\nimport { getFrameNumber, getImg } from \"../../common/utils\"\nimport Game from \"../../Game\"\nimport Scene, { SceneNode } from \"../../common/Scene\"\nimport Match from \"../../stages/Match\"\nimport CardTypes, { CardType } from \"../card/CardTypes\"\nimport { Deck } from \"../card/Deck\"\nimport Card from \"../card/Card\"\n\nconst mechSheet = getImg( require( \"../../www/images/units/ChromeMech2.png\" ) )\n\nexport default class Unit {\n    //assets\n    sprite: HTMLImageElement\n\n    //stats\n    speed: number\n    maxSpeed: number\n    energy: number\n    maxEnergy: number\n    health: number\n    maxHealth: number\n    pos: Vector\n\n    //team\n    teamNumber: number\n    done: boolean\n\n    //Cards\n    draw: Deck = new Deck()\n    hand: Deck = new Deck()\n    discard: Deck = new Deck()\n    drawSpeed: number\n\n    //visualStats\n    color: string\n    name: string\n    hurtTime: number = 0\n    //walking animation\n    walkAnimStep: number = 0\n    walkAnimRate: number = 10 // Tiles per second\n    walkAnimPath?: Vector[]\n\n    constructor( pos, teamNumber = 0, sprite: HTMLImageElement = mechSheet ) {\n        this.sprite = sprite\n        this.name = names[ randomFloor( names.length ) ]\n        this.teamNumber = teamNumber\n        this.color = \"red\"\n        this.done = false\n\n        this.pos = pos\n        this.maxSpeed = 5\n        this.speed = this.maxSpeed\n\n        this.maxEnergy = 2\n        this.energy = this.maxEnergy\n\n        this.maxHealth = 8\n        this.health = this.maxHealth\n\n        this.drawSpeed = 4\n        this.hand.max = 8\n    }\n\n    get team() {\n        return Game.instance.match.teams[ this.teamNumber ]\n    }\n\n    // Model\n    addHealth( amount: number ) {\n        let { energyArmor, plating } = CardTypes\n        let armorCards = [\n            energyArmor,\n            plating\n        ]\n        let reduction = 0\n        if ( amount < 0 ) {\n            // console.log(this.hand.typeCount(energyArmor))\n            this.hurtTime += Math.sqrt( -amount + 1 ) * .1\n            this.hand.cards.forEach( ( card, index ) => {\n                // if (card.type == plating) {\n                //     reduction += plating.damage\n                //     let store = this.hand.cards.splice( index, 1 )\n                //     this.discard.cards.push( store[ 0 ] )\n                // }\n                if (armorCards.includes(card.type) && reduction < Math.abs(amount)) {\n                    reduction += card.type.damage\n                    let store = this.hand.cards.splice( index, 1 )\n                    this.discard.cards.push( store[ 0 ] )\n                }\n            } )\n        }\n        // console.log( \"Reduction:\", reduction )\n        this.health += amount + reduction\n    }\n\n    addMaxHealth( amount: number ) {\n        this.maxHealth += amount\n        if ( amount < 0 )\n            this.hurtTime += Math.sqrt( -amount + 1 ) * .2\n    }\n\n    addSpeed( amount: number ) {\n        this.speed += amount\n    }\n\n    addEnergy( amount: number ) {\n        this.energy += amount\n    }\n\n    capHealth() {\n        let { health, maxHealth } = this\n        this.health = maxHealth < health ? maxHealth : health\n    }\n\n    //Card management\n    gainCard( cardType: CardType, count: number = 1 ) {\n        for ( let i = count; i > 0; i-- ) {\n            if ( this.hand.length < this.hand.max ) {\n                this.hand.add( cardType )\n            } else {\n                this.discard.add( cardType )\n            }\n        }\n    }\n\n    drawCard( amount: number ) {\n        for ( let i = amount; i > 0; i-- ) {\n            // console.log(\"being Called\")\n            if ( this.draw.length > 0 ) {\n                let card = <Card>this.draw.cards.pop()\n                // console.log(\"DrawPile Exists:\", card.type.name)\n                this.hand.cards.push( card )\n            } else {\n                this.discard.emptyInto( this.draw )\n                if ( this.draw.length > 0 ) {\n                    let card = <Card>this.draw.cards.pop()\n                    // console.log(\"DrawPile Doesnt Exists:\", card.type.name)\n                    this.hand.cards.push( card )\n                }\n            }\n        }\n    }\n\n    discardCard( amount: number = 1 ) {\n        for ( let i = amount; i > 0; i-- ) {\n            // console.log(\"being Called\")\n            if ( this.hand.length > 0 ) {\n                let card = <Card>this.hand.cards.pop()\n                // console.log(\"DrawPile Exists:\", card.type.name)\n                this.discard.cards.push( card )\n            }\n        }\n    }\n    discardCardAt( index: number ) {\n        if (index < this.hand.length) {\n            this.discard.insertAtRandom( this.hand.cards.splice( index, 1 )[0] )\n        } else {\n            console.log(\"Error: index is out of range in Unit hand\")\n        }\n    }\n\n    move( path: Vector[] ) {\n        this.pos = path[ path.length - 1 ]\n        this.walkAnimStep = 0\n        this.walkAnimPath = path\n    }\n\n    walkPath( path: Vector[] ) {\n        if ( this.energy > 0 && this.speed > 1 ) {\n            this.move( path )\n            this.energy -= 1\n        }\n    }\n\n    cardCycle() {\n        let { draw, hand, discard, drawSpeed } = this\n        let totalCards = hand.length + draw.length + discard.length\n\n        //empty hand into discard\n        discard.fillFrom( hand )\n        //fill hand from draw pile\n        hand.fillTill( draw, drawSpeed )\n\n        //empty remaining cards from hand into discardPile\n        if ( hand.length < drawSpeed ) {\n            //fill draw pile from discard\n            draw.fillFrom( discard )\n            //fill hand from draw pile\n            hand.fillTill( draw, drawSpeed )\n        }\n    }\n\n    canMove() { return !this.isWalking() }\n    isWalking() { return this.walkAnimPath != undefined }\n\n    statReset() {\n        //Stat Reset\n        this.energy = this.maxEnergy\n        this.speed = this.maxSpeed\n        this.draw.fillFrom( this.hand )\n        this.draw.fillFrom( this.discard )\n        //This assigns a units MAXhealth to their card total\n        this.maxHealth = this.draw.length\n        this.health = this.maxHealth\n        this.cardCycle()\n        this.done = false\n    }\n\n    statCap() {\n        //Stat Cut Off\n        this.capHealth()\n        this.cardCycle()\n        this.done = false\n    }\n\n    update() {\n        let dtSeconds = Game.instance.clock.dt / 1000\n        this.hurtTime = Math.max( 0, this.hurtTime - dtSeconds )\n        let path = this.walkAnimPath\n        if ( path ) {\n            this.walkAnimStep += dtSeconds * this.walkAnimRate\n            if ( this.walkAnimStep + 1 >= path.length )\n                this.walkAnimPath = undefined\n        }\n    }\n\n    // View\n    render( animate = true, flip: boolean = false ) {\n        let g = Graphics.instance\n        let nFrames = this.sprite.height / 32\n        let frame = animate ? getFrameNumber( 2 * nFrames / 2, nFrames ) : 0\n        // let frame = animate ? getFrameNumber( 2, 2 ) : 0\n\n        //walking animation\n        let isWalking = animate && this.isWalking()\n        if ( isWalking ) {\n            let path = this.walkAnimPath as Vector[]\n            let step = Math.floor( this.walkAnimStep )\n            let partialStep = this.walkAnimStep - step\n            let v0 = path[ step ]\n            let v1 = path[ step + 1 ]\n            let animPos = v0.lerp( v1, partialStep )\n            let diff = animPos.subtract( this.pos )\n            g.vTranslate( diff.scale( Match.tileSize ) )\n        }\n        let doShake = animate && this.hurtTime > 0\n        g.c.save()\n        if ( doShake )\n            g.vTranslate( Vector.lissajous( this.hurtTime, 13, 10, 2, 1, 0, 0 ) )\n        if ( flip ) {\n            g.c.translate( 32, 0 )\n            g.c.scale( -1, 1 )\n        }\n        g.drawSheetFrame( this.sprite, 32, 0, 0, frame )\n        g.c.restore()\n    }\n\n    renderName( pos: Vector, textColor: string = \"#c2c2c2\", backing: string = \"#696969\" ) {\n        let g = Graphics.instance\n        g.c.shadowBlur = 0\n        // g.setFont( 3.5, \"pixel\" )\n        g.setFont( 4, \"pixel2\" )\n        let name = this.name\n        const maxLength = 8\n        if ( name.length > maxLength ) {\n            name = name.slice( 0, maxLength - 3 ) + \"...\"\n        }\n        g.drawTextBox( pos, name, { textColor: textColor, boxColor: backing, alignY: TextAlignY.bottom } )\n    }\n\n    drawStats() {\n        let g = Graphics.instance\n        g.c.save()\n        g.c.translate( 0, -7 )\n        this.drawEnergyPips( new Vector( 3, 4 ) )\n        this.drawHealthPips( new Vector( 0.5, 26.5 ) )\n        this.drawSpeedPips( new Vector( 0.5, 33 ) )\n\n        //drawing Speed\n        // let speed = {\n        //     pos: new Vector( 0, 5 )\n        // }\n        // g.strokeRect( speed.pos, new Vector( 7, 8 ), \"rgb(0, 0, 225)\" )\n        // g.drawRect( speed.pos, new Vector( 7, 8 ), \"rgb(50, 50, 255)\" )\n        // g.setFont( 7, \"pixel2\" )\n        // g.drawText( speed.pos.add( new Vector( 2, 0 ) ), ( this.speed - 1 ).toString(), \"rgb(0, 0, 45)\" )\n\n        g.c.restore()\n    }\n\n    drawEnergyPips(pos: Vector) {\n        let g = Graphics.instance\n        //Energy Stats\n        let energy = {\n            pip: {\n                dim: pos,\n                pad: new Vector( 1.5, 0 ),\n                filled: () => `rgb(0, ${ Math.random() * 55 + 200 }, 0)`,\n                empty: \"rgb(0, 100, 0)\",\n                pit: \"rgb(0, 50, 0)\",\n                temp: \"rgb(205, 255, 205)\",\n            },\n            pos: new Vector( 20, 21.5 ),\n            dim: new Vector( 11.5, 4 ),\n            backingColor: \"rgb(30, 125, 30)\",\n        }\n        energy.dim.x = this.energy * energy.pip.dim.x + energy.pip.pad.x * this.energy\n        g.drawRect( energy.pos, energy.dim, energy.backingColor )\n        //draw Empty Pip Containers for Max Energy\n        let mostEnergy = this.energy > this.maxEnergy ? this.energy : this.maxEnergy\n\n        for ( let e = 0; e < mostEnergy; e++ ) {\n            let pipPadding = energy.pip.pad.scale( e )\n            let pipOffset = new Vector( energy.pip.dim.scale( e ).x, 0 ).add( pipPadding )\n            let pipPos = energy.pos.add( new Vector( 0.5, 0 ) ).add( pipOffset )\n\n            if ( e >= this.energy ) {\n                // Empty Pips\n                g.drawRect( pipPos, energy.pip.dim, energy.pip.pit )\n                g.strokeRect( pipPos, energy.pip.dim, energy.pip.empty )\n            } else if ( e < this.maxEnergy ) {\n                // Filled Pips\n                g.strokeRect( pipPos, energy.pip.dim, energy.pip.empty )\n                g.drawRect( pipPos, energy.pip.dim, energy.pip.filled() )\n            } else {\n                // Bonus Pips\n                g.strokeRect( pipPos, energy.pip.dim, \"yellow\" )\n                g.drawRect( pipPos, energy.pip.dim, energy.pip.filled() )\n            }\n\n        }\n    }\n\n    drawHealthPips(pos: Vector) {\n        let g = Graphics.instance\n\n        //Health Stats\n        let health = {\n            pos: pos,\n            dim: new Vector( 33, 4 ),\n            pip: {\n                dim: new Vector( 2.5, 4 ),\n                pad: new Vector( 1.5, 0 ),\n                filled: \"rgb(255, 0, 0)\",\n                empty: \"rgb(100, 0, 0)\",\n                pit: \"rgb(75, 0, 0)\",\n                temp: \"rgb(255, 205, 205)\",\n            },\n            backingColor: \"rgb(125, 10, 10)\"\n        }\n\n        health.dim.x = this.maxHealth * health.pip.dim.x + health.pip.pad.x * this.maxHealth\n        g.drawRect( health.pos, health.dim, health.backingColor )\n        let jiggleCap = 0.4\n        let jiggle = new Vector( randomInt( jiggleCap ), randomInt( jiggleCap ) )\n\n        let mostHealth = this.health > this.maxHealth ? this.health : this.maxHealth\n\n        for ( let h = 0; h < mostHealth; h++ ) {\n            let pipPadding = health.pip.pad.scale( h )\n            let pipOffset = new Vector( health.pip.dim.scale( h ).x, 0 ).add( pipPadding )\n            let pipPos = health.pos.add( new Vector( 1, 0 ) ).add( pipOffset )\n\n            if ( h >= this.health ) {\n                // Empty Pips\n                g.drawRect( pipPos.add( jiggle ), health.pip.dim, health.pip.pit )\n                g.strokeRect( pipPos.add( jiggle ), health.pip.dim, health.pip.empty )\n            } else if ( h < this.maxHealth ) {\n                // Filled Pips\n                g.strokeRect( pipPos, health.pip.dim, health.pip.empty )\n                g.drawRect( pipPos, health.pip.dim, health.pip.filled )\n            } else {\n                // Bonus Pips\n                let bonusTotal = h - this.maxHealth\n                let bonusPipOffset = new Vector( 0, 0 )\n                pipPadding = health.pip.pad.scale( bonusTotal ).add( new Vector( 2, 2 ) )\n                pipOffset = new Vector( health.pip.dim.scale( bonusTotal ).x, 0 ).add( pipPadding )\n                pipPos = health.pos.add( new Vector( 1, 0 ) ).add( pipOffset )\n                g.strokeRect( pipPos, health.pip.dim, \"yellow\" )\n                g.drawRect( pipPos, health.pip.dim, health.pip.filled )\n            }\n            jiggle = new Vector( 0, randomInt( jiggleCap ) )\n        }\n    }\n    drawSpeedPips(pos: Vector) {\n        let g = Graphics.instance\n\n        //Health Stats\n        let speed = {\n            pos: pos,\n            dim: new Vector( 33, 4 ),\n            pip: {\n                dim: new Vector( 2.5, 4 ),\n                pad: new Vector( 1.5, 0 ),\n                filled: \"rgb(100, 100, 255)\",\n                empty: \"rgb(0, 0, 100)\",\n                pit: \"rgb(0, 0, 75)\",\n                temp: \"rgb(205, 205, 255)\",\n            },\n            backingColor: \"rgb(10, 10, 125)\"\n        }\n\n        speed.dim.x = this.maxSpeed * speed.pip.dim.x + speed.pip.pad.x * this.maxSpeed\n        g.drawRect( speed.pos, speed.dim, speed.backingColor )\n        let jiggleCap = 0.4\n        let jiggle = new Vector( randomInt( jiggleCap ), randomInt( jiggleCap ) )\n\n        let mostSpeed = this.speed > this.maxSpeed ? this.speed : this.maxSpeed\n\n        for ( let h = 0; h < mostSpeed; h++ ) {\n            let pipPadding = speed.pip.pad.scale( h )\n            let pipOffset = new Vector( speed.pip.dim.scale( h ).x, 0 ).add( pipPadding )\n            let pipPos = speed.pos.add( new Vector( 1, 0 ) ).add( pipOffset )\n\n            if ( h >= this.speed ) {\n                // Empty Pips\n                g.drawRect( pipPos.add( jiggle ), speed.pip.dim, speed.pip.pit )\n                g.strokeRect( pipPos.add( jiggle ), speed.pip.dim, speed.pip.empty )\n            } else if ( h < this.maxSpeed ) {\n                // Filled Pips\n                g.strokeRect( pipPos, speed.pip.dim, speed.pip.empty )\n                g.drawRect( pipPos, speed.pip.dim, speed.pip.filled )\n            } else {\n                // Bonus Pips\n                let bonusTotal = h - this.maxSpeed\n                let bonusPipOffset = new Vector( 0, 0 )\n                pipPadding = speed.pip.pad.scale( bonusTotal ).add( new Vector( 2, 2 ) )\n                pipOffset = new Vector( speed.pip.dim.scale( bonusTotal ).x, 0 ).add( pipPadding )\n                pipPos = speed.pos.add( new Vector( 1, 0 ) ).add( pipOffset )\n                g.strokeRect( pipPos, speed.pip.dim, \"white\" )\n                g.drawRect( pipPos, speed.pip.dim, speed.pip.filled )\n            }\n            jiggle = new Vector( randomInt( jiggleCap ), 0 )\n        }\n    }\n\n    makeSceneNode() {\n        let game = Game.instance\n        let match = game.match\n        let g = Graphics.instance\n\n        let team = this.team\n        let active = team == match.activeTeam()\n        let { flipUnits } = team\n        let selectedUnit = team.selectedUnit()\n\n        let tileSize = Match.tileSize\n\n        Scene.node( {\n            description: this.name,\n            localMatrix: Matrix.vTranslation( this.pos.scale( tileSize ) ),\n            rect: { width: tileSize, height: tileSize },\n            onClick: () => {\n                if ( game.match.playerTurn() ) {\n                    team.toggleSelectUnit( this )\n                }\n            },\n            onRender: ( node ) => {\n                let hover = node == game.mouseOverData.node\n                let isSelected = this == selectedUnit\n                //Selected? Art\n                g.c.save()\n                if ( active ) {\n                    if ( isSelected ) {\n                        g.c.scale( 1.3, 1.3 )\n                        g.c.translate( -3, -3 )\n                        g.drawRect( new Vector( 0, 0 ), new Vector( tileSize, tileSize ), \"rgba(255, 255, 255, 0.4)\" )\n                    }\n\n                    if ( isSelected && !this.isWalking() ) {\n                        g.c.shadowBlur = 10\n                        g.c.shadowColor = \"black\"\n                    }\n                }\n                if ( flipUnits ) {\n                    g.drawRect( new Vector( 0, 0 ), new Vector( tileSize, tileSize ), \"#00000055\" )\n                } else {\n                    g.drawRect( new Vector( 0, 0 ), new Vector( tileSize, tileSize ), \"#ffffff77\" )\n                }\n                //Standard rendering\n                this.render( true, flipUnits )\n                g.c.restore()\n                if ( hover ) {\n                    // g.drawRect(new Vector(0, 0), new Vector(100, 100), \"red\")\n                    this.drawStats()\n                }\n            }\n        } )\n    }\n\n}","import CardTypes from \"../card/CardTypes\"\nimport { getImg } from \"../../common/utils\"\nimport Unit from \"./Unit\"\n\n// const treant = getImg( require( \"../../www/images/units/moosEnt.png\" ) )\nconst treant = getImg( require( \"../../www/images/units/Vinecent2.png\" ) )\nconst earth = getImg( require( \"../../www/images/units/EarthMech.png\" ) )\nconst chrome = getImg( require( \"../../www/images/units/ChromeMech2.png\" ) )\nconst flesh = getImg( require( \"../../www/images/units/flesh3.png\" ) )\nconst jelly = getImg( require( \"../../www/images/units/GellyMech.png\" ) )\n\n// Start of boss rig types\n\n\n// Gelraug is fast and stabby, but has a low overall hp. \n\nexport class Gelraug extends Unit {\n    constructor( pos, teamNumber ) {\n        super( pos, teamNumber )\n        this.sprite = flesh\n\n        // Gelraug Stats\n        this.maxEnergy += 1;\n        this.energy = this.maxEnergy\n        this.maxSpeed = 5\n        this.speed = this.maxSpeed\n        this.maxHealth = 7\n        this.health = this.maxHealth\n\n        this.draw.cards = []\n        this.draw.add( CardTypes.claw, 3 )\n        this.draw.add( CardTypes.tentacle, 2 )\n        this.draw.add( CardTypes.frenzy, 2)\n        this.draw.add( CardTypes.leap,1)\n        // this.draw.add( CardTypes.acid, 2)\n\n        this.cardCycle()\n        this.statReset()\n    }\n}\n\n//Bulwarkus_Johnson is tanky and tosses loads of mountains but is slow as heck\n\nexport class Bulwarkus_Johnson  extends Unit {\n    constructor( pos, teamNumber ) {\n        super( pos, teamNumber )\n        this.sprite = earth\n\n        // Bulwarkus_Johnson Stats\n        this.maxEnergy += 1;\n        this.energy = this.maxEnergy\n        this.maxSpeed = 3\n        this.speed = this.maxSpeed\n        this.maxHealth = 10\n        this.health = this.maxHealth\n        \n        this.draw.cards = []\n        \n        this.drawSpeed = 6\n\n        //custom cards\n        this.draw.add( CardTypes.plating, 2 )\n\n        this.draw.add( CardTypes.gorge, 1 )\n        this.draw.add( CardTypes.bouldertoss, 2 )\n        this.draw.add( CardTypes.plateShift, 1 )\n        this.draw.add( CardTypes.fuel, 4)\n\n        this.cardCycle()\n        this.statReset()\n\n        this.maxHealth = 10\n        this.health = this.maxHealth\n    }\n}\n\n// End of boss rig types\n\nexport class Chrome extends Unit {\n    constructor( pos, teamNumber ) {\n        super( pos, teamNumber )\n        this.sprite = chrome\n        \n        this.draw.cards = []\n        \n        //custom cards\n        this.draw.add( CardTypes.barrier, 3 )\n\n        this.draw.add( CardTypes.coreCharge, 1 )\n        this.draw.add( CardTypes.rifle, 3 )\n        // this.draw.add( CardTypes.laser, 1 )\n        // this.draw.add( CardTypes.energyFist, 3 )\n        // this.draw.add( CardTypes.grapplingHook, 3 )\n\n        this.cardCycle()\n        this.statReset()\n    }\n}\n\nexport class Treant extends Unit {\n    constructor( pos, teamNumber ) {\n        super( pos, teamNumber )\n        this.sprite = treant\n        \n        //Treant Stats\n        this.maxEnergy += 1;\n        this.energy = this.maxEnergy\n        this.maxSpeed = 4\n        this.speed = this.maxSpeed\n\n        this.draw.cards = []\n\n        this.draw.add( CardTypes.bark, 2 )\n        this.draw.add( CardTypes.sentience, 2 )\n        this.draw.add( CardTypes.fungus, 1 )\n        this.draw.add( CardTypes.boomShroom, 1 )\n        // this.draw.add( CardTypes.bloodClot, 1 )\n\n\n        // this.draw.add( CardTypes.root, 2 )\n        // this.draw.add( CardTypes.perfume, 2 )\n        // // this.draw.add( CardTypes.fruit, 1 )\n        // this.draw.add( CardTypes.flower, 1 )\n\n        this.cardCycle()\n        this.statReset()\n    }\n\n}\nexport class Earth extends Unit {\n    constructor( pos, teamNumber ) {\n        super( pos, teamNumber )\n        this.sprite = earth\n        \n        //Earth Stats\n        this.maxSpeed = 5\n        this.speed = this.maxSpeed\n\n        this.drawSpeed = 5\n\n        this.draw.cards = []\n        \n        this.draw.add( CardTypes.plating, 3 )\n        this.draw.add( CardTypes.exhaustPorts, 1 )\n        \n        this.draw.add( CardTypes.bouldertoss, 2 )\n        this.draw.add( CardTypes.mine, 1 )\n        // this.draw.add( CardTypes.dynamite, 1 )\n        // this.draw.add( CardTypes.gorge, 2 )\n        // this.draw.add( CardTypes.plateShift, 1 )\n\n        this.cardCycle()\n        this.statReset()\n    }\n\n}\nexport class Flesh extends Unit {\n    constructor( pos, teamNumber ) {\n        super( pos, teamNumber )\n        this.sprite = flesh\n\n        // Flesh Stats\n        this.maxSpeed = 5\n        this.speed = this.maxSpeed\n        this.maxHealth = 9\n        this.health = this.maxHealth\n\n        this.draw.cards = []\n\n        this.draw.add( CardTypes.bloodClot, 3 )\n\n        this.draw.add( CardTypes.frenzy, 1 )\n        // this.draw.add( CardTypes.chomp, 1 )\n        this.draw.add( CardTypes.leap, 1 )\n\n        this.draw.add( CardTypes.acid, 1)\n\n        this.cardCycle()\n        this.statReset()\n    }\n}\n\nexport class Jelly extends Unit {\n    constructor( pos, teamNumber ) {\n        super( pos, teamNumber )\n        this.sprite = jelly\n        \n        //Jelly Stats\n        this.maxSpeed = 7\n        this.speed = this.maxSpeed\n        \n        this.draw.cards = []\n        this.draw.add( CardTypes.bubbletoss, 6 )\n        this.draw.add( CardTypes.tentacle, 2 )\n        \n        this.cardCycle()\n        this.statReset()\n    }\n}\nexport class Dummy extends Flesh {\n    constructor( pos, teamNumber ) {\n        super( pos, teamNumber )\n\n        this.maxSpeed = 10\n        this.speed = this.maxSpeed\n        this.drawSpeed = 5\n        \n        this.draw.cards = []\n        this.hand.cards = []\n        this.draw.add( CardTypes.repair, 5)\n        \n        this.cardCycle()\n    }\n}","import { getImg } from \"../common/utils\"\nimport Game from \"../Game\"\nimport Graphics, { TextAlignX } from \"../common/Graphics\"\nimport { randomFloor } from \"../math/math\"\nimport Matrix from \"../math/Matrix\"\nimport { Vector } from \"../math/Vector\"\nimport Scene, { PickingResult, SceneNode } from \"../common/Scene\"\nimport UnitTray from \"../gameobjects/ui/UnitTray\"\nimport { Deck } from \"../gameobjects/card/Deck\"\nimport Card, { getLines } from \"../gameobjects/card/Card\"\nimport { Chrome, Earth, Flesh, Treant } from \"../gameobjects/mech/RigTypes\"\nimport Unit from \"../gameobjects/mech/Unit\"\nimport Team from \"../gameobjects/mech/Team\"\nimport Grid from \"../gameobjects/map/Grid\"\n\n\nconst Jungle = getImg( require( \"../www/images/gui/BackgroundPixel1.png\" ) )\nconst Jungle2 = getImg( require( \"../www/images/gui/BackgroundPixel2.png\" ) )\nconst Swamp = getImg( require( \"../www/images/gui/BackgroundPixel3.png\" ) )\nconst Forest = getImg( require( \"../www/images/gui/BackgroundPixel4.png\" ) )\nconst Backgrounds = [ Jungle, Jungle2, Swamp, Forest ]\n\nconst Grunt = getImg( require( \"../www/images/characters/grunt.png\" ) )\n\nexport default class CardStore {\n    static instance: CardStore\n\n    //-----STORE DATA------\n    scene: SceneNode = { localMatrix: Matrix.scale( Game.uiScale, Game.uiScale ) }\n    unitTray = new UnitTray()\n    stockTotal = 4\n    stock = new Deck( this.stockTotal )\n    isPlayerDone = false\n    \n    //shop keeper dialogue\n    dialogue: {\n        text: string\n        pos: Vector\n        offset: Vector\n    }\n    \n    constructor() {\n        let game = Game.instance\n\n        this.dialogue = {\n            text: \"Buy something!\",\n            pos: new Vector( game.screenDimensions().x - 150, 70 ),\n            offset: new Vector(0, 0)\n        }\n        window.addEventListener( \"keyup\", ev => this.onKeyup( ev ) )\n    }\n\n    reset() {\n        this.stock = new Deck( this.stockTotal )\n    }\n\n    //---------------------------User Input---------------------------\n    onKeyup( ev: KeyboardEvent ) {\n        let game = Game.instance\n        if (game.activity == \"shop\") {\n            if ( ev.key == \"Enter\" ) {\n                game.changeStage(\"route\")\n                game.level += 1\n            }\n            if (ev.key == \"Tab\") {\n                // console.log(game.team.units)\n                // this.team.units = game.units\n                game.team.cycleUnits()\n            }\n        }\n    }\n\n    makeSceneNode() {\n        let g = Graphics.instance\n        let game = Game.instance\n        let match = game.match\n\n        this.scene = Scene.node( {\n            localMatrix: Matrix.identity,\n            onRender: () => {\n                //static Sign data storage\n                const Sign = {\n                    pos: new Vector( game.screenCenter().x, 0 ),\n                    size: new Vector( 20, 25 ),\n                    text: {\n                        size: 30,\n                    }\n                }\n                this.dialogue.pos = new Vector(Game.instance.screenDimensions().x - 150, 70)\n\n                g.c.imageSmoothingEnabled = false\n\n                //Background\n                g.drawRect(new Vector(0, 0), g.size, \"rgba(205, 205, 255, 1)\" )\n\n                //unit display\n                let selected = Game.instance.match.selectedUnit()\n                if (selected) {\n                    g.c.save()\n                    g.c.translate(-20, -10)\n                    g.c.scale(7, 7)\n                    selected.render(false)\n                    g.c.restore()\n                }\n\n                let maxI = 15\n                for (let i = 0; i < maxI; i++) {\n                    g.drawRect(new Vector(0, 0), new Vector(g.size.x, (g.size.y/maxI)*i), \"rgba(50, 50, 50, 0.1)\" )\n                }\n\n                //Shop Keeper\n                g.c.drawImage( Grunt, 0, 0, Grunt.width, Grunt.height, game.screenDimensions().x - 150, 80, 150, 150 )\n\n                //shop keeper dialogue\n                let dialogue = this.dialogue\n                if (dialogue.text.length > 0) {\n                    g.setFont( 10, \"Pixel2\" )\n                    let lines = getLines(dialogue.text, 15)\n                    let textPos = dialogue.pos.add(dialogue.offset)\n                    lines.forEach( ( line, index ) => {\n                        // g.drawText( new Vector( 6, 42 + index * 4 ), line, \"#f0ead8\" )\n                        g.drawTextBox( textPos.add(new Vector( 6, 42 + index * 10 )), line, { boxColor: \"rgba(60,60,150, 1)\", alignX: TextAlignX.center } )\n                    } )\n                }\n                \n                //Shop Sign\n                g.setFont( Sign.text.size, \"Pixel2\" )\n                g.drawText( Sign.pos, \"Part Shop\", \"black\", { boxColor: \"rgba(0, 0, 100, 0.5)\", alignX: TextAlignX.center, padding: 10 } )\n                //Scrip display\n                let scrip = new Vector( game.screenCenter().x, 40 )\n                g.setFont( Sign.text.size-10, \"Pixel2\" )\n                g.drawText( scrip, \"Scrip: \" + Game.instance.scrip, \"white\", { boxColor: \"rgba(150,60,60,0.9)\", padding: 5, alignX: TextAlignX.center } )\n                \n                //Enter to leave display\n                g.drawRect(new Vector(0, 230), new Vector( game.screenDimensions().x, 40), \"black\")\n                g.setFont( 10, \"Pixel2\" )\n                g.drawTextBox(new Vector(game.screenDimensions().x - 150,  240), \"Press 'Enter' to leave\", {})\n                \n            },\n            content: () => {\n                //Unitray\n                this.unitTray.makeSceneNode( new Vector(0, 0), game.team, false)\n\n                //display data(static except for UI Scaling)\n                const screenDims = game.screenDimensions()\n                const shelf = {\n                    dim: new Vector( ( screenDims.x / 5 ) * 3, Card.dimensions.y * 1.3 ),\n                    pos: new Vector( screenDims.x / 7, screenDims.y * 0.6 ),\n                    margin: 10,\n                    cost: 5,\n                    stockPos: ( index: number ) => {\n                        //break and divide the cardSpace by total cards and then divide remaining space evenly\n                        let spacePerCard = shelf.dim.x / ( this.stock.length )\n                        return new Vector( index * spacePerCard + shelf.margin * index, 0 )\n                    }\n                }\n                let selectedIndex = -1\n\n                Scene.node( {\n                    description: \"card-Shelf\",\n                    rect: { width: shelf.dim.x, height: shelf.dim.y },\n                    localMatrix: Matrix.identity.vTranslate( shelf.pos ),\n                    onRender: () => {\n                        g.setFont( 13, \"Times\" )\n                        g.drawTextBox( new Vector( -50, 35 ), \"Cost: \" + shelf.cost, { boxColor: \"rgba(200, 80, 80, 0.9)\" } )\n                    },\n                    content: () => {\n                        this.stock.cards.forEach( ( card, i ) => Scene.node( {\n                            description: \"store-Stock\",\n                            localMatrix: Matrix.translation( shelf.stockPos( i ).x, shelf.stockPos( i ).y ),\n                            scalar: 5,\n\n                            rect: { width: Card.dimensions.x, height: Card.dimensions.y },\n                            onRender: () => {\n                                card.render()\n                                if (selectedIndex == i) {\n                                    g.strokeRect(card.pos, Card.dimensions, \"rgba(255, 255, 255, 0.5)\")\n                                }\n                            },\n                            onHover: () => {\n                                // console.log(card.type.name)\n                                selectedIndex = i\n                            },\n                            onClick: () => {\n                                // console.log(\"Unit:\", unitTray.selectedUnit())\n                                let game = Game.instance\n                                if ( match.selectedUnit() ) {\n                                    if (game.scrip >= shelf.cost) {\n                                        game.scrip -= shelf.cost\n                                        let copy = this.stock.cards.splice( i, 1 )[ 0 ]\n                                        // console.log(\"COPY:\", copy[0])\n                                        match.selectedUnit()?.draw.addCard( copy )\n                                        game.team.selectedUnit()?.statReset()\n                                        // console.log(\"trying to buy!\")\n                                        let possibleText = [\n                                            \"Good Choice\",\n                                            \"I like that one\",\n                                            \"meh\",\n                                            \"At this rate I might pay off the boss\",\n                                            \"Would you like gift wrap?\",\n                                            \"Thats what everyone gets, try a lil originality\"\n                                        ]\n                                        this.dialogue.text = possibleText[randomFloor(possibleText.length)]\n                                    } else {\n                                        let possibleText = [\n                                            \"No scrip, no parts\",\n                                            \"I don't work for free bud\",\n                                            \"Sorry bud, I don't do charity\",\n                                            \"Come back with more money\",\n                                            \"You're short on scrip friend\",\n                                            \"You can't afford that pal\",\n                                            \"Come back when you're a little...Mmmmm 'Richer'\"\n                                        ]\n                                        this.dialogue.text = possibleText[randomFloor(possibleText.length)]\n                                    }\n                                } else {\n                                    this.dialogue.text = \"Hit 'Tab' to select which mech you want that on\"\n                                }\n                            }\n                        } ) )\n                    }\n                } )\n            }\n        } )\n    }\n}","import { getImg } from \"../common/utils\"\nimport Game from \"../Game\"\nimport Graphics, { TextAlignX } from \"../common/Graphics\"\nimport { randomFloor } from \"../math/math\"\nimport Matrix from \"../math/Matrix\"\nimport { Vector } from \"../math/Vector\"\nimport Scene, { PickingResult, SceneNode } from \"../common/Scene\"\nimport UnitTray from \"../gameobjects/ui/UnitTray\"\nimport { Deck } from \"../gameobjects/card/Deck\"\nimport Card from \"../gameobjects/card/Card\"\nimport { Chrome, Earth, Flesh, Treant } from \"../gameobjects/mech/RigTypes\"\nimport Unit from \"../gameobjects/mech/Unit\"\n\n\nconst Jungle = getImg( require( \"../www/images/gui/BackgroundPixel1.png\" ) )\nconst Jungle2 = getImg( require( \"../www/images/gui/BackgroundPixel2.png\" ) )\nconst Swamp = getImg( require( \"../www/images/gui/BackgroundPixel3.png\" ) )\nconst Forest = getImg( require( \"../www/images/gui/BackgroundPixel4.png\" ) )\nconst Backgrounds = [ Jungle, Jungle2, Swamp, Forest ]\n\nexport default class Title {\n    static instance: Title\n    //-----STORE DATA------\n    scene: SceneNode = { localMatrix: Matrix.scale( Game.uiScale, Game.uiScale ) }\n    unitTray = new UnitTray()\n    stockTotal = 5\n    stock = new Deck( this.stockTotal );\n    mechs = <Unit[]>[];\n    isPlayerDone = false\n\n    image: HTMLImageElement\n\n    constructor() {\n        Title.instance = this\n        this.image = Backgrounds[ Math.floor( Math.random() * 4 ) ]\n        window.addEventListener( \"keyup\", ev => this.onKeyup( ev ) )\n    }\n\n    reset() {\n        this.stock = new Deck( 5 )\n        this.mechs = []\n        let mechTypes: ( typeof Unit )[] = [ Chrome, Treant, Flesh, Earth ]\n        for ( let i = 0; i < 3; i++ ) {\n            let random = randomFloor( mechTypes.length )\n            let mechType = mechTypes[ random ]\n            this.mechs.push( new mechType( new Vector( 0, 0 ), 0 ) )\n        }\n    }\n\n    //---------------------------User Input---------------------------\n    onKeyup( ev: KeyboardEvent ) {\n        if ( ev.key == \"Enter\" ) {\n            this.isPlayerDone = true\n        }\n    }\n\n    update() {\n        this.makeSceneNode()\n    }\n\n    makeSceneNode() {\n        let g = Graphics.instance\n        let game = Game.instance\n        let match = game.match\n\n        //static Sign data storage\n        const sign = {\n            pos: new Vector( game.screenCenter().x, 25 ),\n            size: new Vector( 80, 25 ),\n            text: {\n                size: 30,\n            }\n        }\n        const start = {\n            dim: new Vector( 100, 50 ),\n            pos: new Vector(game.screenCenter().x - 125, 100),\n            padding: 10,\n            bulk: 10,\n            text: {\n                size: 13,\n                font: \"Times\",\n            }\n        }\n        const quit = {\n            dim: new Vector( 100, 50 ),\n            pos: new Vector(game.screenCenter().x + 25, 100),\n            padding: 10,\n            bulk: 10,\n            text: {\n                size: 13,\n                font: \"Times\",\n            }\n        }\n\n        this.scene = Scene.node( {\n            localMatrix: Matrix.identity,\n            onRender: () => {\n\n                g.c.imageSmoothingEnabled = false\n                g.c.drawImage( this.image, 0, 0, this.image.width, this.image.height, 0, 0, game.screenDimensions().x, game.screenDimensions().y )\n\n\n                g.setFont( sign.text.size, \"Times New Roman\" )\n                g.drawTextBox( sign.pos, \"Vile Mechs\", { textColor: \"white\", boxColor: \"rgba(0, 0, 100, 0.5)\", alignX: TextAlignX.center, padding: 10 } )\n            },\n            content: () => {\n                Scene.node( {\n                    description: \"start-button\",\n                    rect: { width: start.dim.x, height: start.dim.y },\n                    localMatrix: Matrix.identity.vTranslate( start.pos ),\n                    onHover: () => {\n                        start.padding += start.bulk\n                    },\n                    onRender: () => {\n                        let { padding, dim, text } = start\n                        g.setFont( text.size, text.font )\n                        g.drawRoundTextBox( new Vector(dim.scale(0.5).x, 0), \"Start Game\",\n                        {\n                            boxColor: \"rgba(200, 80, 80, 0.6)\",\n                            alignX: TextAlignX.center,\n                            padding: padding,\n                            borderRadius: 8,\n                        } )\n                    },\n                    onClick: () => {\n                        console.log(\"Trying to startGame!!!!!!\")\n                        Game.instance.changeStage(\"origin\")\n                    },\n                } ),\n                Scene.node( {\n                    description: \"quit-button\",\n                    rect: { width: quit.dim.x, height: quit.dim.y },\n                    localMatrix: Matrix.identity.vTranslate( quit.pos ),\n                    onHover: () => {\n                        quit.padding += quit.bulk\n                    },\n                    onRender: () => {\n                        let { padding, dim, text } = quit\n                        g.setFont( text.size, text.font )\n                        g.drawRoundTextBox( new Vector(dim.scale(0.5).x, 0), \"Quit Game\",\n                        {\n                            boxColor: \"rgba(200, 80, 80, 0.6)\",\n                            alignX: TextAlignX.center,\n                            padding: padding,\n                            borderRadius: 8,\n                        } )\n                    },\n                    onClick: () => {\n                        console.log(\"Trying to quitGame!!!!!!\")\n                        window.close()\n                    },\n                } )\n            }\n        } )\n    }\n}","import { getImg } from \"../common/utils\"\nimport Game from \"../Game\"\nimport Graphics, { TextAlignX } from \"../common/Graphics\"\nimport { randomFloor } from \"../math/math\"\nimport Matrix from \"../math/Matrix\"\nimport { Vector } from \"../math/Vector\"\nimport Scene, { PickingResult, SceneNode } from \"../common/Scene\"\nimport UnitTray from \"../gameobjects/ui/UnitTray\"\nimport { Deck } from \"../gameobjects/card/Deck\"\nimport Card from \"../gameobjects/card/Card\"\nimport { Bulwarkus_Johnson, Chrome, Earth, Flesh, Gelraug, Treant } from \"../gameobjects/mech/RigTypes\"\nimport Unit from \"../gameobjects/mech/Unit\"\n\n\nconst Jungle = getImg( require( \"../www/images/gui/BackgroundPixel1.png\" ) )\nconst Jungle2 = getImg( require( \"../www/images/gui/BackgroundPixel2.png\" ) )\nconst Swamp = getImg( require( \"../www/images/gui/BackgroundPixel3.png\" ) )\nconst Forest = getImg( require( \"../www/images/gui/BackgroundPixel4.png\" ) )\nconst Backgrounds = [ Jungle, Jungle2, Swamp, Forest ]\n\nconst dirt = getImg( require( \"../www/images/cards/backing/BrownCardBase.png\" ) )\n\ntype origin = \"earth\" | \"chrome\"\nexport default class Origin {\n\n    //-----STORE DATA------\n    scene: SceneNode = { localMatrix: Matrix.scale( Game.uiScale, Game.uiScale ) }\n    isPlayerDone = false\n\n    image: HTMLImageElement\n    options : Unit[]\n    selecting: origin | undefined\n\n    constructor() {\n        this.image = Backgrounds[ Math.floor( Math.random() * 4 ) ]\n        this.options = [ new Earth( new Vector(0, 0), 0 ), new Chrome( new Vector(0, 0), 0 ) ]\n    }\n\n    makeSceneNode() {\n        let g = Graphics.instance\n        let game = Game.instance\n        let match = game.match\n\n        this.scene = Scene.node( {\n            localMatrix: Matrix.identity,\n            onRender: () => {\n                g.c.imageSmoothingEnabled = false\n\n                g.c.fillStyle = `rgba(50, 50, 50, 1)`\n                g.c.fillRect( 0, 0, g.size.x, g.size.y )\n                //Color Shift towards center\n                \n                let layers = 10\n                for (let i = 0; i < layers; i++) {\n                    let pos = game.screenDimensions().scale(0.5 / layers * i)\n                    let dim = game.screenDimensions().subtract(pos.scale(2))\n                    \n                    g.c.fillStyle = `rgba(100, 100, 100, ${i/20})`\n                    g.c.fillRect( pos.x, pos.y, dim.x, dim.y )\n                }\n                // g.c.drawImage( this.image, 0, 0, this.image.width, this.image.height, 0, 0, game.screenDimensions().x, game.screenDimensions().y )\n\n                g.setFont( 25, \"Pixel2\" )\n                g.drawText( game.screenCenter().add(new Vector(0, -game.screenDimensions().scale(0.4).y)), \"Select Your Origin\", \"white\", {alignX: TextAlignX.center})\n            },\n            content: () => {\n                const screenDims = game.screenDimensions()\n                const buffer = 5\n                let earth = {\n                    dim: new Vector(100, 100),\n                    pos: new Vector(screenDims.x/5- buffer, screenDims.y/4*2),\n                }\n                let chrome = {\n                    dim: new Vector(100, 100),\n                    pos: new Vector(screenDims.x/4*1.85+ buffer, screenDims.y/4*2),\n                }\n                let gel = {\n                    dim: new Vector(100, 100),\n                    pos: new Vector(screenDims.x/4*3+ buffer, screenDims.y/4*2),\n                }\n                let selecting = <string> \"\"\n                Scene.node( {\n                    description: \"Select a Earth Mech backstory\",\n                    localMatrix: Matrix.identity.vTranslate(earth.pos),\n                    rect: { width: earth.dim.x, height: earth.dim.y },\n                    \n                    onRender: () => {\n                        g.c.imageSmoothingEnabled = false\n                        \n                        let mech = this.options[0]\n                        let textColor = \"rgb(75, 20, 20)\"\n                        //background\n                        g.drawRect(new Vector(0, 0), earth.dim, \"orange\")\n\n                        //mech render\n                        g.c.save()\n                        g.c.translate(5, 0)\n                        g.c.scale(1.5, 1.5)\n                        mech.render()\n                        g.c.restore()\n\n                        //header\n                        g.setFont(12, \"Pixel2\")\n                        g.drawText(new Vector(5, 50), \"Roq Co:\", textColor)\n                        //description\n                        g.setFont(5, \"Pixel2\")\n                        g.drawText(new Vector(7, 65), \"Retired Miner, with a \", textColor)\n                        g.drawText(new Vector(7, 70), \"debt to pay off\", textColor)\n                        //gameplay description\n                        g.drawText(new Vector(7, 80), \"High Area of Effect and Damage\", textColor)\n\n                        //highlight on hover\n                        if ( selecting == \"earth\" ) {\n                            g.strokeRect(new Vector(0, 0), chrome.dim, \"rgba(255, 255, 255)\")\n                        }\n                    },\n                    onHover: () => {\n                        selecting = \"earth\"\n                    },\n                    onClick: () => {\n                        console.log(\"Begin with Earth mech\")\n\n                        Game.instance.team.units = [new Earth(new Vector(0, 0), 0)]\n                        Game.instance.changeStage(\"match\")\n                    }\n                }),\n                Scene.node( {\n                    description: \"Select a Chrome Mech backstory\",\n                    localMatrix: Matrix.identity.vTranslate(chrome.pos),\n                    rect: { width: chrome.dim.x, height: chrome.dim.y },\n                    \n                    onRender: () => {\n                        g.c.imageSmoothingEnabled = false\n                        \n                        let mech = this.options[1]\n                        g.drawRect(new Vector(0, 0), chrome.dim, \"rgb(120, 120, 255)\")\n                        \n                        //mech render\n                        g.c.save()\n                        g.c.translate(5, 0)\n                        g.c.scale(1.5, 1.5)\n                        mech.render()\n                        g.c.restore()\n                        \n                        //Header\n                        g.setFont(12, \"Pixel2\")\n                        g.drawText(new Vector(5, 50), \"M&P inc:\", \"white\")\n                        \n                        //description\n                        g.setFont(5, \"Pixel2\")\n                        g.drawText(new Vector(7, 65), \"Ex Peace Agent with a\", \"white\")\n                        g.drawText(new Vector(7, 70), \"debt to pay off\", \"white\")\n                        //gameplay description\n                        g.drawText(new Vector(7, 80), \"High Defense and Damage\", \"white\")\n\n                        //highlight on hover\n                        if ( selecting == \"chrome\" ) {\n                            g.strokeRect(new Vector(0, 0), chrome.dim, \"rgba(255, 255, 255)\")\n                        }\n                    },\n                    onHover: () => {\n                        selecting = \"chrome\"\n                    },\n                    onClick: () => {\n                        console.log(\"Begin with Chrome mech\")\n\n                        Game.instance.team.units = [new Chrome(new Vector(0, 0), 0)]\n                        Game.instance.changeStage(\"match\")\n                    }\n                })\n            }\n        } )\n    }\n}","import { getImg } from \"../common/utils\"\nimport Game from \"../Game\"\nimport Graphics, { TextAlignX } from \"../common/Graphics\"\nimport { randomFloor } from \"../math/math\"\nimport Matrix from \"../math/Matrix\"\nimport { Vector } from \"../math/Vector\"\nimport Scene, { PickingResult, SceneNode } from \"../common/Scene\"\nimport UnitTray from \"../gameobjects/ui/UnitTray\"\nimport { Deck } from \"../gameobjects/card/Deck\"\nimport Card from \"../gameobjects/card/Card\"\nimport { Chrome, Earth, Flesh, Treant } from \"../gameobjects/mech/RigTypes\"\nimport Unit from \"../gameobjects/mech/Unit\"\n\n\nconst Jungle = getImg( require( \"../www/images/gui/BackgroundPixel1.png\" ) )\nconst Jungle2 = getImg( require( \"../www/images/gui/BackgroundPixel2.png\" ) )\nconst Swamp = getImg( require( \"../www/images/gui/BackgroundPixel3.png\" ) )\nconst Forest = getImg( require( \"../www/images/gui/BackgroundPixel4.png\" ) )\nconst Backgrounds = [ Jungle, Jungle2, Swamp, Forest ]\n\nconst dirt = getImg( require( \"../www/images/cards/backing/BrownCardBase.png\" ) )\n\nexport default class Lose {\n\n    //-----STORE DATA------\n    scene: SceneNode = { localMatrix: Matrix.scale( Game.uiScale, Game.uiScale ) }\n    isPlayerDone = false\n\n    image: HTMLImageElement\n\n    constructor() {\n        this.image = Backgrounds[ Math.floor( Math.random() * 4 ) ]\n        window.addEventListener( \"keyup\", ev => this.onKeyup( ev ) )\n    }\n\n    //---------------------------User Input---------------------------\n    onKeyup( ev: KeyboardEvent ) {\n        if ( ev.key == \"Enter\" ) {\n            this.isPlayerDone = true\n        }\n    }\n\n    makeSceneNode() {\n        let g = Graphics.instance\n        let game = Game.instance\n        let match = game.match\n\n        this.scene = Scene.node( {\n            localMatrix: Matrix.identity,\n            onRender: () => {\n                g.c.imageSmoothingEnabled = false\n\n                g.c.fillStyle = `rgba(50, 50, 50, 1)`\n                g.c.fillRect( 0, 0, g.size.x, g.size.y )\n                //Color Shift towards center\n                \n                let layers = 10\n                for (let i = 0; i < layers; i++) {\n                    let pos = game.screenDimensions().scale(0.5 / layers * i)\n                    let dim = game.screenDimensions().subtract(pos.scale(2))\n                    \n                    g.c.fillStyle = `rgba(100, 100, 100, ${i/20})`\n                    g.c.fillRect( pos.x, pos.y, dim.x, dim.y )\n                }\n                // g.c.drawImage( this.image, 0, 0, this.image.width, this.image.height, 0, 0, game.screenDimensions().x, game.screenDimensions().y )\n\n                g.setFont( 25, \"Pixel2\" )\n                g.drawText( game.screenCenter().add(new Vector(0, -game.screenDimensions().scale(0.4).y)), \"You Lost\", \"white\", {alignX: TextAlignX.center})\n            },\n            content: () => {\n                const screenDims = game.screenDimensions()\n                const buffer = 5\n                let retry = {\n                    dim: new Vector(80, 50),\n                    pos: new Vector(screenDims.x/4- buffer, screenDims.y/4*2),\n                }\n                let quit = {\n                    dim: new Vector(80, 50),\n                    pos: new Vector(screenDims.x/4*2 + buffer, screenDims.y/4*2),\n                }\n                let selecting = <string> \"\"\n\n                Scene.node( {\n                    description: \"Try again\",\n                    localMatrix: Matrix.identity.vTranslate(retry.pos),\n                    rect: { width: retry.dim.x, height: retry.dim.y },\n                    \n                    onRender: () => {\n                        g.c.imageSmoothingEnabled = false\n                        \n                        //background\n                        g.drawRect(new Vector(0, 0), retry.dim, \"white\")\n\n                        //header\n                        g.setFont(17, \"Pixel2\")\n                        g.drawText(new Vector(5, 20), \"Retry?\", \"black\")\n\n                        //highlight on hover\n                        if ( selecting == \"retry\" ) {\n                            g.c.lineWidth = 5\n                            g.strokeRect(new Vector(0, 0), retry.dim, \"black\")\n                        }\n                    },\n                    onHover: () => {\n                        selecting = \"retry\"\n                    },\n                    onClick: () => {\n                        console.log(\"Trying to go again!\")\n                        Game.instance.reset()\n                        Game.instance.changeStage(\"origin\")\n                    }\n                }),\n                Scene.node( {\n                    description: \"Back to title\",\n                    localMatrix: Matrix.identity.vTranslate(quit.pos),\n                    rect: { width: quit.dim.x, height: quit.dim.y },\n                    \n                    onRender: () => {\n                        g.c.imageSmoothingEnabled = false\n                        \n                        //background\n                        g.drawRect(new Vector(0, 0), quit.dim, \"black\")\n\n                        //header\n                        g.setFont(8, \"Pixel2\")\n                        g.drawText(new Vector(5, 20), \"Back to Title?\", \"white\")\n\n                        //highlight on hover\n                        if ( selecting == \"quit\" ) {\n                            g.c.lineWidth = 5\n                            g.strokeRect(new Vector(0, 0), quit.dim, \"rgba(255, 255, 255)\")\n                        }\n                    },\n                    onHover: () => {\n                        selecting = \"quit\"\n                    },\n                    onClick: () => {\n                        console.log(\"Trying to Quit!\")\n                        Game.instance.changeStage(\"title\")\n                    }\n                })\n            }\n        } )\n    }\n}","import { getImg } from \"../common/utils\"\nimport Game from \"../Game\"\nimport Graphics, { TextAlignX } from \"../common/Graphics\"\nimport { randomFloor } from \"../math/math\"\nimport Matrix from \"../math/Matrix\"\nimport { Vector } from \"../math/Vector\"\nimport Scene, { PickingResult, SceneNode } from \"../common/Scene\"\nimport UnitTray from \"../gameobjects/ui/UnitTray\"\nimport { Deck } from \"../gameobjects/card/Deck\"\nimport Card, { getLines } from \"../gameobjects/card/Card\"\nimport { Chrome, Earth, Flesh, Treant } from \"../gameobjects/mech/RigTypes\"\nimport Unit from \"../gameobjects/mech/Unit\"\nimport Team from \"../gameobjects/mech/Team\"\nimport Grid from \"../gameobjects/map/Grid\"\n\n\nconst Jungle = getImg( require( \"../www/images/gui/BackgroundPixel1.png\" ) )\nconst Jungle2 = getImg( require( \"../www/images/gui/BackgroundPixel2.png\" ) )\nconst Swamp = getImg( require( \"../www/images/gui/BackgroundPixel3.png\" ) )\nconst Forest = getImg( require( \"../www/images/gui/BackgroundPixel4.png\" ) )\nconst Backgrounds = [ Jungle, Jungle2, Swamp, Forest ]\n\nconst Grunt = getImg( require( \"../www/images/characters/grunt.png\" ) )\n\nexport default class DealerShip {\n\n    //-----STORE DATA------\n    scene: SceneNode = { localMatrix: Matrix.scale( Game.uiScale, Game.uiScale ) }\n    unitTray = new UnitTray()\n    isPlayerDone = false\n    stock = <Unit[]> []\n\n    image: HTMLImageElement\n\n    //shop keeper dialogue\n    dialogue: {\n        text: string\n        pos: Vector\n        offset: Vector\n    }\n\n    constructor() {\n        this.image = Backgrounds[ Math.floor( Math.random() * 4 ) ]\n        this.dialogue = {\n            text: \"Buy something!\",\n            pos: new Vector(Game.instance.screenDimensions().x - 150, 70),\n            offset: new Vector(0, 0)\n        }\n        window.addEventListener( \"keyup\", ev => this.onKeyup( ev ) )\n    }\n\n    reset() {\n        //console.log()\n        this.stock = [\n            new Chrome(new Vector(0, 0), 0),\n            new Earth(new Vector(0, 0), 0),\n            new Treant(new Vector(0, 0), 0)\n        ]\n    }\n\n    //---------------------------User Input---------------------------\n    onKeyup( ev: KeyboardEvent ) {\n        let game = Game.instance\n        if (game.activity == \"dealerShip\") {\n            if ( ev.key == \"Enter\" ) {\n                game.changeStage(\"route\")\n                game.level += 1\n            }\n            if (ev.key == \"Tab\") {\n                game.team.cycleUnits()\n            }\n        }\n    }\n\n    makeSceneNode() {\n        let g = Graphics.instance\n        let game = Game.instance\n        let match = game.match\n        let selected\n\n        this.scene = Scene.node( {\n            localMatrix: Matrix.identity,\n            onRender: () => {\n                //static Sign data storage\n                const Sign = {\n                    pos: new Vector( game.screenCenter().x, 0 ),\n                    size: new Vector( 20, 25 ),\n                    text: {\n                        size: 30,\n                    }\n                }\n                this.dialogue.pos = new Vector(Game.instance.screenDimensions().x - 150, 70)\n\n                //Background\n                g.c.imageSmoothingEnabled = false\n                g.drawRect(new Vector(0, 0), g.size, \"rgba(205, 205, 255, 1)\" )\n\n                //unit display\n                // let selected = Game.instance.match.selectedUnit()\n                if (selected !== undefined) {\n                    g.c.save()\n                    g.c.translate(-20, -10)\n                    g.c.scale(7, 7)\n                    this.stock[selected].render(false)\n                    g.c.restore()\n                }\n\n                //Background layering\n                let maxI = 15\n                for (let i = 0; i < maxI; i++) {\n                    g.drawRect(new Vector(0, 0), new Vector(g.size.x, (g.size.y/maxI)*i), \"rgba(50, 50, 50, 0.1)\" )\n                }\n\n\n                //Shop Keeper\n                g.c.drawImage( Grunt, 0, 0, Grunt.width, Grunt.height, game.screenDimensions().x - 150, 80, 150, 150 )\n                //shop keeper dialogue\n                let dialogue = this.dialogue\n                if (dialogue.text.length > 0) {\n                    g.setFont( 10, \"Pixel2\" )\n                    let lines = getLines(dialogue.text, 15)\n                    let textPos = dialogue.pos.add(dialogue.offset)\n                    lines.forEach( ( line, index ) => {\n                        // g.drawText( new Vector( 6, 42 + index * 4 ), line, \"#f0ead8\" )\n                        g.drawTextBox( textPos.add(new Vector( 6, 42 + index * 10 )), line, { boxColor: \"rgba(60,60,150, 1)\", alignX: TextAlignX.center } )\n                    } )\n                }\n                \n                //Shop Sign\n                g.setFont( Sign.text.size, \"Pixel2\" )\n                g.drawText( Sign.pos, \"DealerShip\", \"black\", { boxColor: \"rgba(0, 0, 100, 0.5)\", alignX: TextAlignX.center, padding: 10 } )\n                //Scrip display\n                let scrip = new Vector( game.screenCenter().x, 40 )\n                g.setFont( Sign.text.size-10, \"Pixel2\" )\n                g.drawText( scrip, \"Scrip: \" + Game.instance.scrip, \"white\", { boxColor: \"rgba(150,60,60,0.9)\", padding: 5, alignX: TextAlignX.center } )\n                \n                //Enter to leave display\n                g.drawRect(new Vector(0, 230), new Vector( game.screenDimensions().x, 40), \"black\")\n                g.setFont( 10, \"Pixel2\" )\n                g.drawTextBox(new Vector(game.screenDimensions().x - 150,  240), \"Press 'Enter' to leave\", {})\n\n            },\n            content: () => {\n                //Unitray\n                this.unitTray.makeSceneNode( new Vector(0, 0), game.team, false)\n\n                //display data(static except for UI Scaling)\n                const screenDims = game.screenDimensions()\n                const shelf = {\n                    dim: new Vector( ( screenDims.x / 5 ) * 3, Card.dimensions.y * 1.3 ),\n                    pos: new Vector( screenDims.x / 7, screenDims.y * 0.6 ),\n                    margin: 10,\n                    cost: 20,\n                    stockPos: ( index: number ) => {\n                        //break and divide the cardSpace by total cards and then divide remaining space evenly\n                        let spacePerMech = shelf.dim.x / ( this.stock.length )\n                        return new Vector( index * spacePerMech + shelf.margin * index, 0 )\n                    }\n                }\n                let selectedIndex = -1\n\n                Scene.node( {\n                    description: \"mech-Shelf\",\n                    rect: { width: shelf.dim.x, height: shelf.dim.y },\n                    localMatrix: Matrix.identity.vTranslate( shelf.pos ),\n                    onRender: () => {\n                        g.setFont( 13, \"Times\" )\n                        g.drawTextBox( new Vector( -50, 35 ), \"Cost: \" + shelf.cost, { boxColor: \"rgba(200, 80, 80, 0.9)\" } )\n                    },\n                    content: () => {\n                        this.stock.forEach( ( mech, i ) => Scene.node( {\n                            description: \"store-Stock\",\n                            localMatrix: Matrix.translation( shelf.stockPos( i ).x, shelf.stockPos( i ).y ),\n                            scalar: 7,\n\n                            rect: { width: Card.dimensions.x, height: Card.dimensions.y },\n                            onRender: () => {\n                                g.c.save()\n                                g.c.scale(1.5, 1.5)\n                                mech.render()\n                                g.c.restore()\n                                if (selectedIndex == i) {\n                                    g.strokeRect(mech.pos, Card.dimensions, \"rgba(255, 255, 255, 0.5)\")\n                                }\n                            },\n                            onHover: () => {\n                                // console.log(card.type.name)\n                                selectedIndex = i\n                                selected = i\n                            },\n                            onClick: () => {\n                                // console.log(\"Unit:\", unitTray.selectedUnit())\n                                let game = Game.instance\n                                if ( game.team.units.length < game.unitMax ) {\n                                    if (game.scrip >= shelf.cost) {\n                                        game.scrip -= shelf.cost\n                                        let copy = this.stock.splice( i, 1 )[ 0 ]\n                                        // console.log(\"COPY:\", copy[0])\n                                        game.team.units.push(copy)\n                                        // match.selectedUnit()?.draw.addCard( copy )\n                                        // console.log(\"trying to buy!\")\n                                        let possibleText = [\n                                            \"Good Choice\",\n                                            \"I like that one\",\n                                            \"meh\"\n                                        ]\n                                        this.dialogue.text = possibleText[randomFloor(possibleText.length)]\n                                    } else {\n                                        let possibleText = [\n                                            \"No scrip, no parts\",\n                                            \"I don't work for free bud\",\n                                            \"Sorry bud, I don't do charity\",\n                                            \"Come back with more money\",\n                                            \"You're short on scrip friend\",\n                                            \"You can't afford that pal\",\n                                            \"Come back when you're a little...Mmmmm 'Richer'\"\n                                        ]\n                                        this.dialogue.text = possibleText[randomFloor(possibleText.length)]\n                                    }\n                                } else {\n                                    let possibleText = [\n                                        \"You can't store any more bud\",\n                                        \"You've reached your max amount of Mechs pal\",\n                                        \"Come back with less Mechs\"\n                                    ]\n                                    this.dialogue.text = possibleText[randomFloor(possibleText.length)]\n                                }\n                            }\n                        } ) )\n                    }\n                } )\n            }\n        } )\n    }\n}","import { getImg } from \"../common/utils\"\nimport Game from \"../Game\"\nimport Graphics, { TextAlignX } from \"../common/Graphics\"\nimport { randomFloor } from \"../math/math\"\nimport Matrix from \"../math/Matrix\"\nimport { Vector } from \"../math/Vector\"\nimport Scene, { PickingResult, SceneNode } from \"../common/Scene\"\nimport UnitTray from \"../gameobjects/ui/UnitTray\"\nimport { Deck } from \"../gameobjects/card/Deck\"\nimport Card, { getLines } from \"../gameobjects/card/Card\"\nimport { Chrome, Earth, Flesh, Treant } from \"../gameobjects/mech/RigTypes\"\nimport Unit from \"../gameobjects/mech/Unit\"\nimport Team from \"../gameobjects/mech/Team\"\nimport Grid from \"../gameobjects/map/Grid\"\nimport CardTray from \"../gameobjects/ui/CardTray\"\n\nconst Jungle = getImg( require( \"../www/images/gui/BackgroundPixel1.png\" ) )\nconst Jungle2 = getImg( require( \"../www/images/gui/BackgroundPixel2.png\" ) )\nconst Swamp = getImg( require( \"../www/images/gui/BackgroundPixel3.png\" ) )\nconst Forest = getImg( require( \"../www/images/gui/BackgroundPixel4.png\" ) )\nconst Backgrounds = [ Jungle, Jungle2, Swamp, Forest ]\n\nconst Grunt = getImg( require( \"../www/images/characters/grunt.png\" ) )\n\nexport default class PawnShop {\n    static instance: PawnShop\n\n    //-----STORE DATA------\n    scene: SceneNode = { localMatrix: Matrix.scale( Game.uiScale, Game.uiScale ) }\n    unitTray = new UnitTray()\n    isPlayerDone = false\n    cardTray: CardTray = new CardTray()\n    \n    //shop keeper dialogue\n    dialogue: {\n        text: string\n        pos: Vector\n        offset: Vector\n    }\n    \n    constructor() {\n        let game = Game.instance\n\n        this.dialogue = {\n            text: \"Hit 'Tab' to sell mech parts!\",\n            pos: new Vector( game.screenDimensions().x - 150, 70 ),\n            offset: new Vector(0, 0)\n        }\n        window.addEventListener( \"keyup\", ev => this.onKeyup( ev ) )\n    }\n\n    reset() {\n        // this.stock = new Deck( this.stockTotal )\n    }\n    toggleHand() {\n        let game = Game.instance\n        // console.log( game.team.units[0].hand.cards )\n        // game.team.selectedUnit()?.statReset()\n        game.team.selectedUnit()?.cardCycle()\n        \n    }\n\n    //---------------------------User Input---------------------------\n    onKeyup( ev: KeyboardEvent ) {\n        let game = Game.instance\n        if (game.activity == \"pawnShop\") {\n            if ( ev.key == \"Enter\" ) {\n                game.changeStage( \"route\" )\n                game.level += 1\n            }\n            if (ev.key == \"Tab\") {\n                // console.log(game.team.units)\n                // this.team.units = game.units\n                game.team.cycleUnits()\n                this.toggleHand()\n                this.dialogue.text = \"Sell something!\"\n            }\n        }\n    }\n\n    makeSceneNode() {\n        let g = Graphics.instance\n        let game = Game.instance\n\n        this.scene = Scene.node( {\n            localMatrix: Matrix.identity,\n            onRender: () => {\n                //static Sign data storage\n                const Sign = {\n                    pos: new Vector( game.screenCenter().x, 0 ),\n                    size: new Vector( 20, 25 ),\n                    text: {\n                        size: 30,\n                    }\n                }\n                this.dialogue.pos = new Vector(Game.instance.screenDimensions().x - 150, 70)\n\n                g.c.imageSmoothingEnabled = false\n\n                //Background\n                g.drawRect(new Vector(0, 0), g.size, \"rgba(205, 205, 255, 1)\" )\n\n                //unit display\n                let selected = game.team.selectedUnit()\n                if (selected) {\n                    g.c.save()\n                    g.c.translate(-20, -10)\n                    g.c.scale(7, 7)\n                    selected.render(false)\n                    g.c.restore()\n                }\n\n                let maxI = 15\n                for (let i = 0; i < maxI; i++) {\n                    g.drawRect(new Vector(0, 0), new Vector(g.size.x, (g.size.y/maxI)*i), \"rgba(50, 50, 50, 0.1)\" )\n                }\n\n                //Shop Keeper\n                g.c.drawImage( Grunt, 0, 0, Grunt.width, Grunt.height, game.screenDimensions().x - 150, 80, 150, 150 )\n\n                //shop keeper dialogue\n                let dialogue = this.dialogue\n                if (dialogue.text.length > 0) {\n                    g.setFont( 10, \"Pixel2\" )\n                    let lines = getLines(dialogue.text, 15)\n                    let textPos = dialogue.pos.add(dialogue.offset)\n                    lines.forEach( ( line, index ) => {\n                        // g.drawText( new Vector( 6, 42 + index * 4 ), line, \"#f0ead8\" )\n                        g.drawTextBox( textPos.add(new Vector( 6, 42 + index * 10 )), line, { boxColor: \"rgba(60,60,150, 1)\", alignX: TextAlignX.center } )\n                    } )\n                }\n                \n                //Shop Sign\n                g.setFont( Sign.text.size, \"Pixel2\" )\n                g.drawText( Sign.pos, \"Pawn Shop\", \"black\", { boxColor: \"rgba(0, 0, 100, 0.5)\", alignX: TextAlignX.center, padding: 10 } )\n                //Scrip display\n                let scrip = new Vector( game.screenCenter().x, 40 )\n                g.setFont( Sign.text.size-10, \"Pixel2\" )\n                g.drawText( scrip, \"Scrip: \" + Game.instance.scrip, \"white\", { boxColor: \"rgba(150,60,60,0.9)\", padding: 5, alignX: TextAlignX.center } )\n                \n                //Enter to leave display\n                g.drawRect(new Vector(0, 230), new Vector( game.screenDimensions().x, 40), \"black\")\n                g.setFont( 10, \"Pixel2\" )\n                g.drawTextBox(new Vector(game.screenDimensions().x - 150,  240), \"Press 'Enter' to leave\", {})\n                \n            },\n            content: () => {\n                //Unitray\n                this.unitTray.makeSceneNode( new Vector(0, 0), game.team, false)\n                if (game.team.selectedUnit()) {\n                    this.cardTray.update(game.team.selectedUnit()!)\n                }\n\n                //display data(static except for UI Scaling)\n                const screenDims = game.screenDimensions()\n                const shelf = {\n                    dim: new Vector( ( screenDims.x / 5 ) * 3, Card.dimensions.y * 1.3 ),\n                    pos: new Vector( screenDims.x / 7, screenDims.y * 0.6 ),\n                    margin: 10,\n                    cost: 10,\n                    stockPos: ( index: number ) => {\n                        //break and divide the cardSpace by total cards and then divide remaining space evenly\n                        let spacePerCard = 0\n                        if ( game.team.selectedUnit() ) {\n                            spacePerCard = shelf.dim.x / ( game.team.selectedUnit()!.hand.cards.length )\n                        }\n                        return new Vector( index * spacePerCard + shelf.margin * index, 0 )\n                    }\n                }\n                let selectedIndex = -1\n\n                Scene.node( {\n                    description: \"card-Shelf\",\n                    rect: { width: shelf.dim.x, height: shelf.dim.y },\n                    localMatrix: Matrix.identity.vTranslate( shelf.pos ),\n                    onRender: () => {\n                        g.setFont( 13, \"Times\" )\n                        g.drawTextBox( new Vector( -50, 35 ), \"Cost: \" + shelf.cost, { boxColor: \"rgba(200, 80, 80, 0.9)\" } )\n                    },\n                    content: () => {\n                        if ( game.team.selectedUnit() ) {\n                            game.team.selectedUnit()!.hand.cards.forEach( ( card, i ) => Scene.node( {\n                                description: \"store-Stock\",\n                                localMatrix: Matrix.translation( shelf.stockPos( i ).x, shelf.stockPos( i ).y ),\n                                scalar: 5,\n                                \n                                rect: { width: Card.dimensions.x, height: Card.dimensions.y },\n                                onRender: () => {\n                                    card.render()\n                                    if (selectedIndex == i) {\n                                        g.strokeRect(card.pos, Card.dimensions, \"rgba(255, 255, 255, 0.5)\")\n                                    }\n                                },\n                                onHover: () => {\n                                    // console.log(card.type.name)\n                                    selectedIndex = i\n                                },\n                                onClick: () => {\n                                    // console.log(\"Unit:\", unitTray.selectedUnit())\n                                    let game = Game.instance\n                                    if ( game.team.selectedUnit() ) {\n                                        if (game.scrip >= shelf.cost) {\n                                            game.scrip -= shelf.cost\n                                            //selling\n                                            game.team.selectedUnit()!.hand.cards.splice( i, 1 )\n                                            game.team.selectedUnit()?.statReset()\n                                            // console.log(\"trying to sell!\")\n                                            let possibleText = [\n                                                \"Been looking for this part\",\n                                                \"I love this one\",\n                                                \"meh\"\n                                            ]\n                                            this.dialogue.text = possibleText[randomFloor(possibleText.length)]\n                                        } else {\n                                            let possibleText = [\n                                                \"No scrip, no parts\",\n                                                \"I don't work for free bud\",\n                                                \"Sorry bud, I don't do charity\",\n                                                \"Come back with more money\",\n                                                \"You're short on scrip friend\",\n                                                \"You can't afford that pal\",\n                                                \"Come back when you're a little, Mmm... 'Richer'\"\n                                            ]\n                                            this.dialogue.text = possibleText[randomFloor(possibleText.length)]\n                                        }\n                                    } else {\n                                        this.dialogue.text = \"Hit 'Tab' to select which mech you want that on\"\n                                    }\n                                }\n                            } ) )\n                        }\n                    }\n                } )\n            }\n        } )\n    }\n}","import { Activity } from \"../../Game\";\n\nclass Stop<T> {\n    public next: Stop<T> | null = null;\n    public prev: Stop<T> | null = null;\n    constructor(public data: T) {}\n}\n\ninterface ILinkedList<T> {\n    insertInBegin(data: T): Stop<T>;\n    insertAtEnd(data: T): Stop<T>;\n    deleteNode(node: Stop<T>): void;\n    traverse(): T[];\n    size(): number;\n    search(comparator: (data: T) => boolean): Stop<T> | null;\n}\n\nexport interface Post {\n    title: Activity;\n}\n\nexport default class LinkedList<T> implements ILinkedList<T> {\n    private head: Stop<T> | null = null;\n  \n    public insertInBegin(data: T): Stop<T> {\n        const node = new Stop(data);\n        if (!this.head) {\n            this.head = node;\n        } else {\n            this.head.prev = node;\n            // node.next = this.head;\n            this.head = node;\n        }\n        return node;\n    }\n    public insertAtEnd(data: T): Stop<T> {\n        const node = new Stop(data);\n        if (!this.head) {\n            this.head = node;\n        } else {\n            const getLast = (node: Stop<T>): Stop<T> => {\n                return node.next ? getLast(node.next) : node;\n            };\n    \n          const lastNode = getLast(this.head);\n          node.prev = lastNode;\n          lastNode.next = node;\n        }\n        return node;\n    }\n    public deleteNode(node: Stop<T>): void {\n        if (!node.prev) {\n            this.head = node.next;\n        } else {\n            const prevNode = node.prev;\n            prevNode.next = node.next;\n        }\n    }\n\n    public traverse(): T[] {\n        const array: T[] = [];\n        if (!this.head) {\n            return array;\n        }\n    \n        const addToArray = (node: Stop<T>): T[] => {\n            array.push(node.data);\n            return node.next ? addToArray(node.next) : array;\n        };\n        return addToArray(this.head);\n    }\n    public size(): number {\n        return this.traverse().length;\n    }\n    public search(comparator: (data: T) => boolean): Stop<T> | null {\n        const checkNext = (node: Stop<T>): Stop<T> | null => {\n          if (comparator(node.data)) {\n            return node;\n          }\n          return node.next ? checkNext(node.next) : null;\n        };\n    \n        return this.head ? checkNext(this.head) : null;\n      }\n}","import { getImg } from \"../../common/utils\"\nimport Game, { Activity } from \"../../Game\"\nimport Graphics, { TextAlignX } from \"../../common/Graphics\"\nimport { randomCeil, randomFloor } from \"../../math/math\"\nimport Matrix from \"../../math/Matrix\"\nimport { Vector } from \"../../math/Vector\"\nimport Scene, { PickingResult, SceneNode } from \"../../common/Scene\"\nimport LinkedList, { Post } from \"./LinkedList\"\nimport Camera from \"../../gameobjects/Camera\"\nimport { findSourceMap } from \"module\"\nimport { match } from \"assert\"\n\nconst dirt = getImg( require( \"../../www/images/cards/backing/BrownCardBase.png\" ) )\n\nexport default class Route {\n\n    //-----STORE DATA------\n    scene: SceneNode = { localMatrix: Matrix.scale( Game.uiScale, Game.uiScale ) }\n    isPlayerDone = false\n\n    // image: HTMLImageElement\n    options : LinkedList<Post>[]\n    selected : boolean = false\n    pos: Vector = new Vector(0, 0)\n    scroll: number = 0\n    camera: Camera\n\n    constructor() {\n        //Path init\n        this.options = []\n        this.reset( 3 )\n        this.camera = new Camera()\n        window.addEventListener( \"keydown\", ev => this.onKeydown( ev ) )\n    }\n\n    onKeydown( ev: KeyboardEvent ) {\n        // console.log(\"ev\", ev.key)\n        if (Game.instance.activity == \"route\") {\n            // if ( ev.key == \"w\" || ev.key == \"ArrowUp\" ) {\n            //     this.scroll -= 5\n            // }\n            // if ( ev.key == \"s\" || ev.key == \"ArrowDown\" ) {\n            //     this.scroll += 5\n            // }\n        }\n    }\n    get length() {\n        // let longest = 0\n        // this.options.forEach(option => {\n        //     let length = option.traverse.length\n        //     if ( length > longest) {\n        //         longest = length\n        //     }\n        // })\n        return 6\n    }\n    reset(length: number = 3) {\n        this.options = [\n            this.getNewPath(1),\n            this.getNewPath(3),\n            this.getNewPath(6),\n            this.getNewPath(4),\n            this.getNewPath(2)\n        ]\n    }\n    getNewPath(length: number = 3) {\n        let game = Game.instance\n        const linkedList = new LinkedList<Post>()\n\n        for (let i = 0; i < length; i++) {\n            let nextStop: Activity = \"match\"\n            if (i == length - 1) {\n                nextStop = game.randomShop\n            }\n            linkedList.insertAtEnd({ title: nextStop })\n        }\n        return linkedList\n    }\n    makeSceneNode() {\n        let g = Graphics.instance\n        let game = Game.instance\n\n        this.scene = Scene.node( {\n            localMatrix: Matrix.identity,\n            content: () => {\n                const screenDims = game.screenDimensions()\n                const buffer = 5\n                type Stage = {\n                    id: Activity\n                    description: string\n                    color: string\n                    title: string\n                }\n                //UI Variable\n                let selecting : Vector = new Vector(-1, -1)\n                this.options.forEach((route, i) => {\n                    // this.path.traverse().forEach(( stop, i ) => {\n                    route.traverse().forEach(( stop, j ) => {\n                        let currentSlot = new Vector(i, j)\n                        let stageStats: Stage\n                        switch (stop.title) {\n                            case \"match\": {\n                                stageStats = {\n                                    id: \"match\", description: \"Fight!\", color: \"rgb(255, 0, 0)\", title: \"Bounty Hunt\"\n                                }\n                                break\n                            }\n                            case \"shop\": {\n                                stageStats = {\n                                    id: \"shop\", description: \"Buy Cards\", color: \"rgb(20, 20, 175)\", title: \"Mechanic\"\n                                }\n                                break\n                            }\n                            case \"dealerShip\": {\n                                stageStats = {\n                                    id: \"dealerShip\", description: \"Buy Mechs\", color: \"rgb(50, 175, 50)\", title: \"Mech Dealer\"\n                                }\n                                break\n                            }\n                            case \"pawnShop\": {\n                                stageStats = {\n                                    id: \"pawnShop\", description: \"Remove Cards\", color: \"rgb(50, 0, 75)\", title: \"Pawn Shop\"\n                                }\n                                break\n                            }\n                            default: {\n                                stageStats = {\n                                    id: \"route\", description: \"mystery\", color: \"rgb(150, 150, 150)\", title: \"???\"\n                                }\n                            }\n                        }\n                        let dim = new Vector(50, 20)\n                        let pos = new Vector(screenDims.x/6, screenDims.y/6*5)\n                        let offset = new Vector(buffer*i+dim.x*i, -buffer*j-dim.y*j - this.scroll)\n                        let finalPos = pos.add(offset)\n                        let valid = j == game.level\n                        Scene.node( {\n                            description: stageStats.description,\n                            localMatrix: Matrix.identity.vTranslate(finalPos),\n                            rect: { width: dim.x, height: dim.y },\n                            \n                            onRender: () => {\n                                g.c.imageSmoothingEnabled = false\n                                \n                                //background\n                                g.drawRect(new Vector(0, 0), dim, stageStats.color)\n                                \n                                //header\n                                g.setFont(6, \"Pixel2\")\n                                g.drawText(new Vector(2, 2), stageStats.title, \"white\")\n                                \n                                if (!valid) {\n                                    g.drawRect(new Vector(0, 0), dim, \"rgba(0, 0, 0, 0.8)\")\n                                }\n\n                                //highlight on hover\n                                if ( selecting.equals(currentSlot) && valid ) {\n                                    let { color } = stageStats\n                                    g.c.lineWidth = 6\n                                    //editting each color string to have rgba and an alpha value\n                                    let alphadColor = \"rgba\" + color.split(\"rgb\")[1].toString().split(\")\")[0] + \", 0.7)\"\n                                    // console.log(\"alphadColor:\", alphadColor)\n                                    g.strokeRect(new Vector(0, 0), dim, alphadColor)\n                                } else if ( selecting.equals(currentSlot) ) {\n                                    g.c.lineWidth = 1\n                                    g.strokeRect(new Vector(0, 0), dim, \"rgba(0, 0, 0)\")\n                                }\n                            },\n                            onHover: () => {\n                                selecting = new Vector(i, j)\n                            },\n                            onClick: valid ? () => {\n                                Game.instance.changeStage(stageStats.id)\n                            } : () => {}\n                        })\n                    })\n                })\n                let bossPos = new Vector(50, 0)\n                let bossDim = new Vector(200, 50)\n                let bossSelected = false\n                let bossValid = game.level >= this.length\n                Scene.node( {\n                    description: \"Debt Collector\",\n                    localMatrix: Matrix.identity.vTranslate(bossPos),\n                    rect: { width: bossDim.x, height: bossDim.y },\n\n                    onRender: () => {\n                        g.c.imageSmoothingEnabled = false\n                        \n                        //background\n                        g.drawRect(bossPos, bossDim, \"red\")\n                        \n                        //header\n                        g.setFont(25, \"Pixel2\")\n                        g.drawText(bossPos.add(new Vector(bossDim.x*0.12, bossDim.x*0.07)), \"Boss Fight\", \"white\")\n                        \n                        //highlight on hover\n                        if (!bossValid) {\n                            g.drawRect(bossPos, bossDim, \"rgba(0, 0, 0, 0.8)\")\n                        } else {\n                            if (bossSelected) {\n                                g.c.lineWidth = 5\n                                g.strokeRect(bossPos, bossDim, \"white\")\n                            }\n                        }\n                    },\n                    onHover: () => {\n                        bossSelected = true\n                    },\n                    onClick: () => {\n                        let game = Game.instance\n                        game.changeStage(\"match\")\n                        // game.match.startBoss()\n                        // game.match.teams[1] = game.match.generateBoss()\n                    }\n                })\n            },\n            onRender: () => {\n                g.c.imageSmoothingEnabled = false\n\n                g.c.fillStyle = `rgba(120, 120, 120, 1)`\n                g.c.fillRect( 0, 0, g.size.x, g.size.y )\n                //Color Shift towards center\n                \n                let layers = 10\n                for (let i = 0; i < layers; i++) {\n                    let pos = game.screenDimensions().scale(0.5 / layers * i)\n                    let dim = game.screenDimensions().subtract(pos.scale(2))\n\n                    g.c.fillStyle = `rgba(180, 160, 120, ${i/20})`\n                    g.c.fillRect( pos.x, pos.y, dim.x, dim.y )\n                }\n                // g.setFont( 25, \"Pixel2\" )\n                // g.drawText(\n                //     game.screenCenter().add(new Vector(0,\n                //     -game.screenDimensions().scale(0.4).y)),\n                //     \"Select Next Stage\", \"white\",\n                //     { alignX: TextAlignX.center }\n                // )\n            }\n        } )\n    }\n}","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"cgtuV\")).toString();","import { Vector } from \"./math/Vector\"\nimport Matrix from \"./math/Matrix\"\nimport Match from './stages/Match'\nimport Input from \"./common/Input\"\nimport Graphics, { TextAlignX } from \"./common/Graphics\"\nimport \"./common/GlobalTypes\"\nimport { PickingResult, SceneNode } from \"./common/Scene\"\nimport Scene from \"./common/Scene\"\nimport Camera from \"./gameobjects/Camera\"\nimport Clock from \"./common/Clock\"\nimport Unit from \"./gameobjects/mech/Unit\"\nimport content from \"*.css\"\nimport Team from \"./gameobjects/mech/Team\"\nimport { Bulwarkus_Johnson, Chrome, Earth, Flesh, Gelraug, Jelly, Treant } from \"./gameobjects/mech/RigTypes\"\nimport CardStore from \"./stages/CardStore\"\nimport Grid from \"./gameobjects/map/Grid\"\nimport { randomFloor } from \"./math/math\"\nimport Title from \"./stages/Title\"\nimport Origin from \"./stages/Origin\"\nimport Lose from \"./stages/Lose\"\nimport DealerShip from \"./stages/DealerShip\"\nimport PawnShop from \"./stages/PawnShop\"\nimport Route from \"./stages/route/Route\"\n\nconst vacationurl = require( './www/audio/Vacation.mp3' )\nlet vacation = new Audio( vacationurl )\nconst knockurl = require( './www/audio/Knock.mp3' )\nlet knock = new Audio( knockurl )\n\n// activity \nexport type Activity = \n    //mid-screens\n    \"title\" |\n    \"origin\" |\n    \"lose\" |\n    //stat testing\n    \"match\" |\n    //stat management\n    \"shop\" |\n    \"dealerShip\" |\n    \"pawnShop\" |\n    //test plans\n    \"route\"\n\nexport default class Game {\n    static instance: Game\n    static uiScale = 3\n    static camVelocityDecay = 0.85\n    graphics = new Graphics()\n    input = new Input()\n    scene: SceneNode = { localMatrix: Matrix.scale( Game.uiScale, Game.uiScale ) }\n    mouseOverData: PickingResult = { node: undefined, point: new Vector( 0, 0 ) }\n    \n    //Scene List (paired with their relevant stats)\n    title: Title\n    origin: Origin\n    lose: Lose\n\n    store: CardStore\n    dealerShip: DealerShip\n    pawnShop: PawnShop\n\n    route: Route\n    \n    scrip: number\n    scripRewards : number[]\n\n    match: Match\n    level: number = 0\n    \n    // units : Unit[]\n    team: Team\n    unitMax : number = 3\n\n\n    //Dev stats\n    showSceneDebug = false\n    showFPS = false\n    clock = new Clock()\n\n    isPlayerDone = false\n\n    activity: Activity = \"title\"\n\n    constructor() {\n        Game.instance = this\n\n        //Transition Stages\n        this.title = new Title()\n        this.lose = new Lose()\n        this.origin = new Origin()\n        this.route = new Route()\n\n        //Shop Stages\n        this.store = new CardStore()\n        this.store.reset()\n        this.dealerShip = new DealerShip()\n        this.dealerShip.reset()\n        this.pawnShop = new PawnShop()\n        this.pawnShop.reset()\n\n        //Store Init\n        this.scrip = 20\n        this.scripRewards = [50, 40, 30, 20, 10]\n        \n        //player team Init\n        let units = [\n            new Earth(new Vector(0, 0), 0),\n            // new Chrome(new Vector(0, 0), 0),\n            // new Treant(new Vector(0, 0), 0),\n            // new Flesh(new Vector(0, 0), 0),\n        ]\n        \n        this.team = new Team(\"Choden Warriors\", units, false, 0)\n        //Match Init\n        this.match = new Match( this.team )\n        if (this.activity == \"match\") {\n            this.match.start()\n        }\n\n        window.addEventListener( \"click\", ev => this.onClick( ev ) )\n        window.addEventListener( \"resize\", ev => this.graphics.onResize() )\n        window.addEventListener( \"keyup\", ev => this.onKeyup( ev ) )\n        window.addEventListener( \"keydown\", ev => this.onKeydown( ev ) )\n    }\n    // get team() {\n    //     let playerTeam = new Team(\"Choden Warriors\", this.units, false, 0)\n    //     // playerTeam.units = this.units\n    //     return playerTeam\n    // }\n    get randomUnit() {\n        let mechList = [\n            new Chrome( new Vector( 0, 0 ), 1 ),\n            new Earth( new Vector( 0, 0 ), 1 )\n        ]\n        let random = randomFloor( mechList.length )\n        return mechList[ random ]\n    }\n    get randomBoss() {\n        let mechList = [\n            new Gelraug( new Vector( 0, 0 ), 1 ),\n            new Bulwarkus_Johnson( new Vector( 0, 0 ), 1 )\n        ]\n        let random = randomFloor( mechList.length )\n        return mechList[ random ]\n    }\n    // get randomStage() {\n    //     let options: Activity[] = [\n    //         \"match\",\n    //         \"shop\",\n    //         \"pawnShop\",\n    //         \"dealerShip\"\n    //     ]\n    //     let randomPick = options[randomFloor(options.length)]\n    //     return randomPick\n    // }\n    get randomShop() {\n        let options: Activity[] = [\n            \"shop\",\n            \"pawnShop\",\n            \"dealerShip\"\n        ]\n        let randomPick = options[randomFloor(options.length)]\n        return randomPick\n    }\n    reset() {\n        this.level = 1\n        this.scrip = 20\n    }\n    \n    changeStage( stage: Activity ) {\n        let delay = 100\n        window.setTimeout(() => {\n            switch (stage) {\n                case \"match\": {\n                    this.level += 1\n                    if (this.level >= this.route.length) {\n                        this.match.startBoss()\n                    } else {\n                        this.match.start()\n                    }\n                }\n                case \"shop\": {\n                    this.store.reset()\n                    this.activity = stage\n                }\n                case \"route\": {\n                    let peak = 0\n                    this.route.options.forEach(option => {\n                        if (option.traverse().length >= peak) {\n                            peak = option.traverse().length\n                        }\n                    })\n                    if (this.level > peak) {\n                        this.route.reset(6)\n                    }\n                }\n                default: {\n                    this.activity = stage\n                }\n            }\n        }, delay)\n    }\n    //----------------MODEL------------------\n    get scripReward() {\n        let rewardIndex = this.match.timer >= this.scripRewards.length ? this.scripRewards.length - 1 : this.match.timer\n        return this.scripRewards[ rewardIndex ]\n    }\n    //----------------------UPDATE----------------------------\n    update() {\n        let { match } = this\n        this.clock.nextFrame()\n\n        if (this.activity == \"match\") {\n            this.match.update()\n        }\n\n        this.makeSceneNode()\n        //user Input Display\n        this.mouseOverData = Scene.pick( this.scene, this.input.cursor )\n        let { node, point } = this.mouseOverData\n        if ( node?.onHover )\n            node.onHover( node, point )\n    }\n\n    //---------------------------User Input---------------------------\n    onClick( ev: MouseEvent ) {\n        let cursor = this.input.cursor\n        let { node, point } = Scene.pick( this.scene, cursor )\n        if ( node && !this.input.keys.get( \"shift\" ) ) {\n            if ( node.onClick )\n                node.onClick( node, point )\n        }\n    }\n    \n    onKeyup( ev: KeyboardEvent ) {\n        if ( ev.key == \"`\" ) {\n            this.showSceneDebug = !this.showSceneDebug\n        }\n        if ( ev.key == \",\" ) {\n            this.showFPS = !this.showFPS\n        }\n    }\n    onKeydown( ev: KeyboardEvent ) {\n        if ( ev.key == \"Tab\" ) {\n            ev.preventDefault()\n        }\n    }\n\n    //--------------------------RENDER-----------------------------\n    render() {\n        let g = this.graphics\n        g.c.imageSmoothingEnabled = false\n        g.c.fillStyle = \"#2b69f5\"\n        g.c.fillRect( 0, 0, g.size.x, g.size.y )\n        g.c.textBaseline = \"top\"\n        let picked = Scene.pickNode( this.scene, this.input.cursor )\n        if ( this.showSceneDebug ) {\n            if ( picked ) picked.debugColor = \"white\"\n            Scene.render( g.c, this.scene, true )\n            g.setFont( 12, \"pixel\" )\n            g.drawText( this.input.cursor.add( Vector.one.scale( 20 ) ), picked?.description ?? \"\", \"white\" )\n        } else {\n            Scene.render( g.c, this.scene, false )\n        }\n\n        if ( this.showFPS ) {\n            g.setFont( 24, \"impact\" )\n            g.drawText( Vector.one.scale( 2 ), this.clock.averageFPS.toFixed( 2 ), \"red\" )\n        }\n    }\n    makeSceneNode() {\n        let g = Graphics.instance\n        let { match, store } = this\n        let { unitTray, cardTray } = this.match\n        let selectedUnit = this.match.activeTeam().selectedUnit()\n        let center = Game.instance.screenCenter()\n        this.scene = Scene.node( {\n            localMatrix: Matrix.scale( Game.uiScale, Game.uiScale ),\n            onRenderPost: () => {\n                if ( this.activity == \"match\" ) {\n                    //TEAM NAME DISPLAY\n                    // g.setFont( 6, \"pixel\" )\n                    // g.drawTextBox( new Vector( center.x, 0 ), this.match.activeTeam().name, {\n                    //     textColor: \"#c2c2c2\", boxColor: \"#6969698f\", alignX: TextAlignX.center\n                    // } )\n                    //Money / Reward for current round, and Timer\n                    g.setFont( 5, \"pixel\" )\n                    g.drawTextBox( new Vector( center.x/4, 0 ), `SCRIP Reward: ${ this.scripReward } `, {\n                        textColor: \"#c2c2c2\", boxColor: \"rgba(200, 80, 80, 0.7)\", alignX: TextAlignX.left\n                    } )\n                    g.drawTextBox( new Vector( center.x/4, 8 ), `SCRIP: ${ this.scrip } `, {\n                        textColor: \"#c2c2c2\", boxColor: \"rgba(200, 80, 80, 0.7)\", alignX: TextAlignX.left\n                    } )\n                }\n            },\n            content: () => {\n                switch (this.activity) {\n                    case \"shop\":\n                        //-----------------Card Shop Display-------------------\n                        store.makeSceneNode()\n                        break\n                    case \"dealerShip\":\n                        //-----------------Mech Shop Display-------------------\n                        this.dealerShip.makeSceneNode()\n                        break\n                    case \"pawnShop\":\n                        //-----------------Pawn Shop Display-------------------\n                        this.pawnShop.makeSceneNode()\n                        // unitTray.makeSceneNode( new Vector( 0, 0 ), this.team )\n                        break\n                    case \"match\" || \"boss\":\n                        //-----------------Match Display-----------------------\n                        match.makeSceneNode()\n                        g.c.restore()\n                        if ( this.match.turn == 0 ) {\n                            unitTray.makeSceneNode( new Vector( 0, 0 ), match.teams[ 0 ] )\n                        } else {\n                            //display Unit Tray backwords for second player\n                            unitTray.makeSceneNode( new Vector( this.screenDimensions().x, 0 ), match.activeTeam(), true )\n                        }\n                        if ( selectedUnit ) {\n                            cardTray.makeSceneNode( selectedUnit )\n                        }\n                        break\n                    case \"title\":\n                        //Title\n                        this.title.makeSceneNode()\n                        break \n                    case \"origin\":\n                        //Origin\n                        this.origin.makeSceneNode()\n                        break \n                    case \"lose\":\n                        //Lose\n                        this.lose.makeSceneNode()\n                        break \n                    case \"route\":\n                        //Pathfinding to the next match\n                        this.route.makeSceneNode()\n                        break \n                }\n            }\n        } )\n    }\n    screenDimensions() { return this.graphics.size.scale( 1 / Game.uiScale ) }\n    screenCenter() { return this.graphics.size.scale( 0.5 / Game.uiScale ) }\n}","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"eLZc0\")).toString();","import Game from \"./Game\"\nlet game = new Game()\n//this is where we navigate between menus and game\n\nfunction loop() {\n    game.update()\n    game.render()\n    window.requestAnimationFrame( loop )\n}\nloop()"],"names":["$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$export$f7ad0328861e2f03","$18c11f3350a906ea$var$mapping","pairs","keys","Object","i","length","id","resolved","Error","module","exports","URL","parcelRequire","resolve","import","meta","url","toString","register","JSON","parse","equals","a","b","Math","abs","randomFloor","upperLimit","floor","random","randomInt","contains","min","max","x","clamp","lerp","start","end","alpha","Vector","y","this","subtract","other","add","addXY","product","scale","ceil","distance","signs","sign","beta","sqrt","unit","clampLength","t","xFreq","yFreq","xAmplitude","yAmplitude","xPhase","yPhase","cos","PI","sin","zero","one","right","down","Matrix","m11","m12","m13","m21","m22","m23","m31","m32","m33","multiply","multiplyMatrix","inverse","determinant","multiplyVec","v","z","translate","translation","vTranslate","vTranslation","angle","s","c","rotate","rotation","preTranslationX","preTranslationY","scaleX","scaleY","translationX","translationY","px","py","sx","sy","print","rows","columnWidths","map","column","e","reduce","pad","n","padStart","result","row","join","console","log","range","res","push","determinant2","a11","a12","a21","a22","determinant3","args","a13","a23","a31","a32","a33","destructureMatrix","name","j","identity","body","flat","Function","k","det2","d","index","getImg","src","Image","Graphics","instance","canvas","document","getElementById","getContext","onResize","rect","getBoundingClientRect","width","height","size","drawRect","pos","color","fillStyle","fillRect","drawRoundRect","radius","beginPath","moveTo","arcTo","closePath","fill","strokeRect","strokeStyle","strokeCircle","arc","stroke","fillCircle","drawPip","dim","pipBlock","value","radix","vertical","empty","pipDim","buffer","lineWidth","pipPos","costDisplay","cost","color1","color2","fontSize","setFont","drawText","makePath","path","lineTo","font","textDimensions","text","metrics","measureText","actualBoundingBoxAscent","actualBoundingBoxDescent","options","padding","textColor","alignX","boxColor","TextAlignX","left","alignY","TextAlignY","top","p","p2","textBoxDims","textOffset","fillText","drawTextBox","textBoxOffset","drawRoundTextBox","borderRadius","drawSheetFrame","img","frameHeight","frame","w","h","drawImage","center","bottom","BasicTile","super","traversalCost","elevation","texture","getTraversalCost","getElevation","render","save","restore","Grass","require","GrassHill","Infinity","WaterShallow","WaterDeep","$a07fab4af3cbb7ce$var$F2","$a07fab4af3cbb7ce$var$G2","$a07fab4af3cbb7ce$var$F4","$a07fab4af3cbb7ce$var$G4","$a07fab4af3cbb7ce$var$grad3","Float32Array","$a07fab4af3cbb7ce$var$grad4","$a07fab4af3cbb7ce$export$7cef8d54b4fb09be","constructor","randomOrSeed","seed","s0","s1","s2","mash","data","charCodeAt","$a07fab4af3cbb7ce$var$masher","$a07fab4af3cbb7ce$var$alea","Uint8Array","i1","r","aux","$a07fab4af3cbb7ce$export$98cd52c6119fe283","perm","permMod12","noise2D","n0","n1","n2","x0","y0","j1","x1","y1","x2","y2","ii","jj","t0","gi0","t1","gi1","t2","gi2","noise3D","n3","z0","k1","i2","j2","k2","z1","z2","x3","y3","z3","kk","t3","gi3","noise4D","n4","l","w0","rankx","ranky","rankz","rankw","l1","l2","i3","j3","k3","l3","w1","w2","w3","x4","y4","z4","w4","ll","t4","gi4","Grid","simplex","$c67f8a8c9110b245$require$SimplexNoise","content","Tiles","randomize","blockChance","setFromXY","randomize2","amplitude","rFreq","radius2","amplitude2","rFreq2","frequency","hyp","hypot","radialProjection","radialProjection2","radialTest","radialTest2","clearUnitPaths","landingDim","limit","bonusPos","set","newMap","placeUnits","units","iter","teamNumber","placeUnit","placing","player1","occupied","forEach","getFromXY","error","get","startX","startY","endX","endY","isEmpty","offsetOrderings","getMoves","tilePairity","useDiagonals","findPath","match","origin","destination","maxDepth","makeNode","parent","rebuildPath","node","steps","reverse","isWalkable","destKey","currLayer","nextLayer","visited","Set","offsets","offset","pos2","freeAlongX","freeAlongY","key","has","node2","tmp","Scene","openNode","children","Array","isArray","debug","localMatrix","transform","onRender","debugColor","globalAlpha","child","onRenderPost","pick","point","visitNode","addParentReferences","ancestor","relativeMatrix","vector","Team","flip","selectedUnitIndex","playable","scene","flipUnits","hasUnitSelected","setUnitIndex","Game","cardTray","deselect","toggleSelectIndex","toggleSelectUnit","indexOf","cycleUnits","selectUnit","selectedUnit","getUnit","endTurn","speed","maxSpeed","startTurn","energy","maxEnergy","statCap","update","filter","health","ore","laser","energyArmor","shieldCharge","energyFist","barrier","boulder","mine","gorge","blastCharge","dynamite","plating","claw","frendzi","leap","lump","chomp","acid","bloodClot","sprint","repair","grapplingHook","rifle","pollen","fruit","root","flower","bark","fungus","boomShroom","jelly","tentacle","warp","flesh","brown","green","metal","purple","grass","CardTypes","getDescription","card","type","damage","sprite","backing","canApplyToEmptyTiles","getTilesInRange","user","rookStyleTargets","onApplyToTile","target","addHealth","animationFrame","g","tileSize","userPos","targetPos","renderFrames","minDist","friendly","targetsWithinRange","drawCard","exhaustive","gainCard","coreCharge","count","draw","fuel","lastTile","targetsAlongLine","ignoreObstacles","pop","mobile","bouldertoss","halfTile","endTile","heightBump","midPos","yCurve","noiseVector","spot","plateShift","getTilesEffected","tilesEffected","tile","ignoreElevation","Card","cards","addEnergy","discard","passable","direction","step","round","exhaustPorts","drawCount","healthCost","frenzy","insertAtRandom","maxHp","sentience","addMaxHealth","hand","discardCardAt","heal","addSpeed","bullet","spread","noise","xShift","yShift","newPos","move","perfume","speedCost","bubbletoss","store","$2703caff557e1afc$export$2e2bcd8739ae039","cardTypeList","values","randomCardType","delta","undefined","inBounds","contained","val","maxDist","dx","dy","cardType","yRotation","dimensions","dark","light","red","blue","getLines","line","apply","charsPerLine","words","split","lines","word","nextLine","CardTray","lastSelectTime","isPickingTarget","hasCardSelected","selectedCard","selectIndex","Date","now","onSelectUnit","lerpCards","decks","deck","game","selectionTimeout","playerTurn","handPosition","drawPosition","discardPosition","handBase","handLength","marigin","handMargin","screenSize","screenDimensions","restingDepth","cardIndex","stride","makeSceneNode","description","onHover","onClick","isSelectedCard","UnitTray","team","yOffset","dimLength","renderName","drawStats","AI","maxChodiness","delay","chodiness","think","startTime","teams","idealSpot","enemies","getEnemiesOf","useCard","moveTowards","bestTarget","bestTargetOf","selectBestCard","active","reset","getFriendsOf","friends","best","possibleTargets","enemy","closestTargetTo","closest","tiles","targets","friend","playableCards","choice","applyCardAt","findCloseOrFarSpot","close","record","bar","tilePath","closestPath","friendlySpace","getPath","location","walkableLength","walkablePath","slice","walkPath","Camera","zoom","SQRT2","zoomLevel","velocityDecay","position","velocity","worldToCamera","screenWidth","screenHeight","transformation","cameraToWorld","worldPosition","screenPosition","onKeyup","ev","changeZoom","onWheel","deltaY","zoomIn","dz","input","acceleration","targetPosition","lerpTarget","isInFocusArea","lastDragPosition","cursor","diff","diffPrime","startDragging","stopDragging","distFromViewport","screenCenter","screenDims","Match","setCameraTarget","playerTeam","camera","timer","turn","unitTray","aiTeamNumbers","ai","cardAnim","rate","cap","window","addEventListener","unitsGenerator","moveCamToUnit","moveCamToFirstUnit","activeTeam","generateMap","generateBoss","randomBoss","generateEnemies","funds","enemyTotal","bonusCardTotal","randomUnit","randomCard","statReset","playerUnits","isPickingCard","goBack","costs","isEnoughEnergy","isEnoughSpeed","splice","animateCard","checkUnits","hasFocus","mouseOverData","tileSpaceCursor","toLocalSpace","changeStage","scrip","scripReward","level","activity","startBoss","onMousedown","button","middleClick","rightClick","pickNode","worldClicked","nothingClicked","isMovingUnit","onMouseup","uiScale","imageSmoothingEnabled","imageSmoothingQuality","drawMap","cursorWalkable","canMove","pathLength","trimmedSteps","walkableColor","unwalkableColor","pathBacking","setLineDash","endpoint","numbered","currentPos","textPos","currentText","pickingCard","cameraTransform","cell","isValidTarget","highlight","highlightTarget","possibleTarget","cardImpactZone","adjustedPos","Input","Map","codes","mouse","toLowerCase","code","Clock","lastFrame","performance","averageFPS","dt","dtSeconds","nextFrame","FPS","$d2cb9d8ad7103424$export$2e2bcd8739ae039","trim","Deck","total","typeCount","insertAt","addCard","addCards","addCardsatRandom","removeCards","desired","emptyInto","fillFrom","drawTotal","fillTill","drawTill","that","amount","cardPosition","mechSheet","Unit","hurtTime","walkAnimStep","walkAnimRate","names","done","maxHealth","drawSpeed","armorCards","reduction","includes","capHealth","discardCard","walkAnimPath","cardCycle","isWalking","clock","animate","nFrames","fps","numberOfFrames","time","getFrameNumber","partialStep","v0","v1","doShake","lissajous","shadowBlur","maxLength","drawEnergyPips","drawHealthPips","drawSpeedPips","pip","filled","pit","temp","backingColor","mostEnergy","pipPadding","pipOffset","jiggle","mostHealth","bonusTotal","mostSpeed","hover","isSelected","shadowColor","treant","earth","chrome","Gelraug","Bulwarkus_Johnson","Chrome","Treant","Earth","Flesh","Grunt","CardStore","stockTotal","stock","isPlayerDone","dialogue","Sign","selected","shelf","margin","stockPos","spacePerCard","selectedIndex","scalar","copy","possibleText","Backgrounds","Title","mechs","image","mechTypes","mechType","bulk","quit","Origin","selecting","mech","Lose","retry","DealerShip","spacePerMech","unitMax","PawnShop","toggleHand","Stop","next","prev","LinkedList","insertInBegin","head","insertAtEnd","getLast","lastNode","deleteNode","traverse","array","addToArray","search","comparator","checkNext","Route","scroll","onKeydown","getNewPath","linkedList","nextStop","randomShop","title","route","stop","stageStats","currentSlot","finalPos","valid","alphadColor","bossPos","bossDim","bossSelected","bossValid","$74a4bb3be1d6b79c$exports","Audio","vacationurl","$13536026fae42a4f$exports","knockurl","graphics","showSceneDebug","showFPS","lose","dealerShip","pawnShop","scripRewards","mechList","stage","setTimeout","peak","option","rewardIndex","preventDefault","textBaseline","picked","toFixed","camVelocityDecay","loop","requestAnimationFrame"],"version":3,"file":"index.ad6db622.js.map"}